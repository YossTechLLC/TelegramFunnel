================================================================================
GCWEBHOOK & GCHOSTPAY CLOUD TASKS ARCHITECTURE ANALYSIS
================================================================================

Date: 2025-10-26
Analysis: Evaluating whether GCWebhook10-26 and GCHostPay10-26 should be split
          into multiple services using Google Cloud Tasks architecture, similar
          to the GCSplit1/2/3 pattern.

================================================================================
EXECUTIVE SUMMARY
================================================================================

After thorough analysis of GCWebhook10-26 and GCHostPay10-26, comparing them to
the GCSplit architecture pattern, here are the findings:

GCWebhook10-26:
  âœ… RECOMMENDATION: DO NOT SPLIT
  - No external API calls that are prone to downtime
  - Single HTTP call to GCSplit1 (internal service, highly available)
  - Splitting would add unnecessary complexity with minimal benefit

GCHostPay10-26:
  âš ï¸  RECOMMENDATION: OPTIONAL SPLIT (CONSIDER CAREFULLY)
  - Makes ChangeNow API status check (documented to have downtime)
  - Makes Alchemy RPC API calls (generally reliable, 99.9% SLA)
  - Current internal retry logic (3 attempts) may be sufficient
  - Splitting could improve resilience but adds complexity and latency

CRITICAL CONSIDERATION:
  The GCHostPay workflow is time-sensitive. ChangeNow transactions have
  expiration times. Infinite retry via Cloud Tasks (up to 24 hours) could
  cause transactions to expire, resulting in failed payments.

================================================================================
SECTION 1: CURRENT ARCHITECTURE OVERVIEW
================================================================================

1.1 GCWebhook10-26 (Webhook Service)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Service: GCWebhook10-26
File: tph10-26.py (650 lines)
Endpoints: 1
  - GET / (send_invite)

Workflow:
  1. Receive GET request with token parameter
  2. Fetch secrets from Secret Manager (bot token, signing key)
  3. Decode and verify signed token
  4. Calculate subscription expiration time
  5. Record user subscription in database (Cloud SQL)
  6. Send Telegram invite link (Telegram Bot API)
  7. Trigger payment split webhook (HTTP POST to GCSplit1)
  8. Return 200 OK

External Dependencies:
  - Google Cloud Secret Manager (secrets)
  - Cloud SQL PostgreSQL (database)
  - Telegram Bot API (invite sending)
  - GCSplit1 HTTP endpoint (payment split trigger)

Key Functions:
  - decode_and_verify_token(): Validates HMAC signature
  - calculate_expiration_time(): Calculates subscription expiry
  - record_private_channel_user(): Database INSERT/UPDATE
  - trigger_payment_split_webhook(): HTTP POST to GCSplit1


1.2 GCHostPay10-26 (Host Wallet Payment Service)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Service: GCHostPay10-26
Files:
  - tphp10-26.py (476 lines) - Main Flask app
  - wallet_manager.py (634 lines) - Web3 payment logic
  - alchemy_webhook_handler.py (304 lines) - Alchemy Notify webhooks
  - database_manager.py - Database operations

Endpoints: 3
  - POST / (hostpay_webhook) - Main payment endpoint
  - POST /alchemy-webhook (alchemy_webhook) - Alchemy Notify callbacks
  - GET /health (health_check) - Health monitoring

Workflow (Main Endpoint):
  1. Receive POST request with encrypted token
  2. Fetch signing key from Secret Manager
  3. Decode and verify HostPay token
  4. Check if transaction already processed (database)
  5. Check ChangeNow transaction status (ChangeNow API)
     â†³ EXTERNAL API CALL - Can fail/timeout
  6. Validate status is "waiting"
  7. Execute ETH payment via wallet_manager (Alchemy RPC API)
     â†³ EXTERNAL API CALL - Can fail/timeout
     - Get gas prices (Alchemy API)
     - Build transaction
     - Sign transaction
     - Broadcast transaction (Alchemy RPC)
     - Wait for confirmation (Alchemy RPC, 300s timeout)
     - Internal retry: 3 attempts with 10s delay
     - Transaction replacement logic for stuck transactions
  8. Log transaction to database (Cloud SQL)
  9. Return 200 OK

External Dependencies:
  - Google Cloud Secret Manager (secrets)
  - Cloud SQL PostgreSQL (database)
  - ChangeNow API (transaction status check)
  - Alchemy RPC API (Ethereum blockchain operations)
  - Alchemy Notify (webhook callbacks for tx updates)

Key Modules:
  - WalletManager: Handles all Web3/Ethereum operations
    - send_eth_payment(): Main entry point
    - _send_transaction_with_retry(): 3 retry attempts
    - _get_optimized_gas_price(): Alchemy gas optimization
    - _replace_stuck_transaction(): Handles stuck transactions
  - AlchemyWebhookHandler: Processes Alchemy Notify callbacks
  - DatabaseManager: Database operations


1.3 GCSplit Architecture (For Comparison)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
The GCSplit service was split into 3 microservices to isolate external API
calls and implement infinite retry logic using Cloud Tasks.

GCSplit1-10-26: Payment Splitting Orchestrator
  File: tps1-10-26.py (742 lines)
  Endpoints: 3
    - POST / (initial_webhook) - Receives from GCWebhook
    - POST /usdt-eth-estimate (receive_usdt_eth_estimate) - Receives from GCSplit2
    - POST /eth-client-swap (receive_eth_client_swap) - Receives from GCSplit3

  Responsibilities:
    - Receive payment split requests from GCWebhook
    - Calculate adjusted amounts (remove TP fee)
    - Insert into split_payout_request table
    - Insert into split_payout_que table
    - Coordinate workflow via encrypted tokens
    - Trigger GCHostPay via Cloud Tasks

  External Dependencies:
    - Cloud SQL (database)
    - Cloud Tasks (orchestration)
    - NO direct ChangeNow API calls

GCSplit2-10-26: USDTâ†’ETH Estimator
  File: tps2-10-26.py (245 lines)
  Endpoints: 1
    - POST / (process_usdt_eth_estimate)

  Responsibilities:
    - Receive encrypted token from GCSplit1
    - Call ChangeNow API for USDTâ†’ETH estimate (with infinite retry)
    - Return encrypted response to GCSplit1 via Cloud Tasks

  External Dependencies:
    - Cloud Tasks (orchestration)
    - ChangeNow API (USDTâ†’ETH estimate) â† ISOLATED HERE

  Key Feature: INFINITE RETRY for ChangeNow API calls
    - Retries until success or 24-hour Cloud Tasks timeout
    - Handles ChangeNow API downtime gracefully

GCSplit3-10-26: ETHâ†’ClientCurrency Swapper
  File: tps3-10-26.py (262 lines)
  Endpoints: 1
    - POST / (process_eth_client_swap)

  Responsibilities:
    - Receive encrypted token from GCSplit1
    - Create ChangeNow fixed-rate transaction (ETHâ†’ClientCurrency) (with infinite retry)
    - Return encrypted response to GCSplit1 via Cloud Tasks

  External Dependencies:
    - Cloud Tasks (orchestration)
    - ChangeNow API (create transaction) â† ISOLATED HERE

  Key Feature: INFINITE RETRY for ChangeNow API calls
    - Retries until success or 24-hour Cloud Tasks timeout
    - Handles ChangeNow API downtime gracefully

Why GCSplit Was Split:
  1. Isolate external API dependencies (ChangeNow) that are prone to downtime
  2. Implement infinite retry logic via Cloud Tasks (24-hour max)
  3. Ensure payment splitting completes even if ChangeNow is temporarily down
  4. Single responsibility: Each service has one external API dependency
  5. Resilience: If one API call fails, only that component retries

Cloud Tasks Configuration:
  - 5 queues: gcsplit2_queue, gcsplit1_response_queue, gcsplit3_queue,
              gcsplit1_response_queue (reused), hostpay_queue
  - Max retry duration: 24 hours
  - Exponential backoff
  - Automatic retry on failure

================================================================================
SECTION 2: GCWEBHOOK10-26 DETAILED ANALYSIS
================================================================================

2.1 Current Architecture
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GCWebhook is a monolithic Flask service with a single primary endpoint.

Flow Diagram:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ GET /?token=<signed_token>                                               â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 1. Fetch Telegram bot token & signing key from Secret Manager           â”‚
  â”‚    Dependencies: Google Cloud Secret Manager                             â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 2. Decode and verify signed token                                        â”‚
  â”‚    Function: decode_and_verify_token()                                   â”‚
  â”‚    - Parse binary-packed token (base64)                                  â”‚
  â”‚    - Extract: user_id, channel_id, wallet_address, payout_currency,     â”‚
  â”‚               payout_network, subscription_time_days, subscription_price â”‚
  â”‚    - Verify HMAC-SHA256 signature (truncated to 16 bytes)               â”‚
  â”‚    - Check timestamp expiration (2-hour window)                          â”‚
  â”‚    Dependencies: LOCAL (no external API)                                 â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 3. Calculate subscription expiration time                                â”‚
  â”‚    Function: calculate_expiration_time()                                 â”‚
  â”‚    Dependencies: LOCAL (datetime calculation)                            â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 4. Record user subscription in database                                  â”‚
  â”‚    Function: record_private_channel_user()                               â”‚
  â”‚    Table: private_channel_users_database                                 â”‚
  â”‚    Operation: INSERT or UPDATE                                           â”‚
  â”‚    Dependencies: Cloud SQL PostgreSQL                                    â”‚
  â”‚    Failure Mode: Non-fatal - user still gets invite if this fails        â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 5. Send Telegram invite link                                             â”‚
  â”‚    Function: bot.create_chat_invite_link() + bot.send_message()         â”‚
  â”‚    Dependencies: Telegram Bot API                                        â”‚
  â”‚    Failure Mode: CRITICAL - user doesn't get invite                      â”‚
  â”‚    Reliability: Telegram API is highly reliable (99.9%+ uptime)          â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 6. Trigger payment split webhook                                         â”‚
  â”‚    Function: trigger_payment_split_webhook()                             â”‚
  â”‚    Target: GCSplit1-10-26 (HTTP POST)                                    â”‚
  â”‚    Payload: user_id, closed_channel_id, wallet_address,                  â”‚
  â”‚             payout_currency, payout_network, subscription_price          â”‚
  â”‚    Signature: HMAC-SHA256 in X-Webhook-Signature header                  â”‚
  â”‚    Timeout: 30 seconds                                                   â”‚
  â”‚    Dependencies: GCSplit1 HTTP endpoint (internal service)               â”‚
  â”‚    Failure Mode: Non-fatal - user gets invite but no payment split       â”‚
  â”‚    Reliability: GCSplit1 should be highly available (internal service)   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 7. Return 200 OK                                                         â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


2.2 Potential Breakdown Points
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Analyzing each step for potential failure scenarios:

Step 1: Fetch secrets from Secret Manager
  - Failure scenario: Secret Manager down (extremely rare)
  - Impact: HTTP 500, entire request fails
  - Mitigation: Secret Manager has 99.95% SLA, can cache secrets at startup
  - Should we split? NO - Secret Manager is infrastructure, not worth splitting

Step 2: Decode and verify token
  - Failure scenario: Invalid token, signature mismatch, expired token
  - Impact: HTTP 400, request rejected (expected behavior)
  - Mitigation: N/A - this is input validation
  - Should we split? NO - local operation, no external dependency

Step 3: Calculate expiration time
  - Failure scenario: None (simple datetime calculation)
  - Impact: N/A
  - Should we split? NO - local operation

Step 4: Record in database
  - Failure scenario: Cloud SQL connection failure, query timeout
  - Impact: User still gets invite (non-fatal in current implementation)
  - Mitigation: Connection pooling, retry on transient errors
  - Should we split? NO - database is reliable, non-fatal failure

Step 5: Send Telegram invite
  - Failure scenario: Telegram API down, rate limiting, network timeout
  - Impact: CRITICAL - user doesn't get invite link
  - Mitigation: None currently
  - Should we split? MAYBE - but Telegram API is highly reliable (99.9%+)
  - Analysis: Telegram downtime is extremely rare, splitting adds complexity

Step 6: Trigger payment split webhook
  - Failure scenario: GCSplit1 down, network timeout, connection error
  - Impact: User gets invite but payment doesn't split (CRITICAL for business)
  - Mitigation: None currently (single HTTP POST with 30s timeout)
  - Should we split? MAYBE - this is the most likely failure point
  - Analysis:
    - GCSplit1 is an internal service, should be highly available
    - If GCSplit1 is down, splitting won't help (still need GCSplit1 up)
    - HOWEVER: If GCSplit1 is temporarily overloaded or restarting, Cloud
      Tasks retry would ensure the webhook eventually succeeds


2.3 Potential Split Architecture
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
If we were to split GCWebhook, here's how it would look:

Option 1: Split Payment Split Webhook Trigger
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

GCWebhook1-10-26: Main Service
  Endpoints: 1
    - GET / (send_invite)

  Workflow:
    1. Fetch secrets
    2. Decode and verify token
    3. Calculate expiration
    4. Record in database
    5. Send Telegram invite
    6. Enqueue Cloud Task to GCWebhook2
    7. Return 200 OK

  Changes:
    - Replace direct HTTP POST to GCSplit1 with Cloud Task enqueue
    - Add Cloud Tasks client initialization

GCWebhook2-10-26: Payment Split Webhook Trigger
  Endpoints: 1
    - POST / (trigger_payment_split)

  Workflow:
    1. Receive encrypted token from GCWebhook1 (via Cloud Tasks)
    2. Decrypt token
    3. HTTP POST to GCSplit1 with retry logic
    4. Return 200 OK

  Benefits:
    - If GCSplit1 is temporarily down, Cloud Tasks retries automatically
    - Infinite retry (up to 24 hours)
    - GCWebhook1 returns quickly, doesn't wait for payment split

  Drawbacks:
    - Adds latency (user gets invite immediately, but payment split is delayed)
    - Adds complexity (2 services instead of 1)
    - Requires new Cloud Tasks queue
    - Requires token encryption/decryption
    - If GCSplit1 is down for > 24 hours, payment split fails anyway

Flow Diagram (Split):
  GCWebhook receives request
    â†“
  GCWebhook1: Send invite, record DB
    â†“
  Cloud Tasks (webhook_trigger_queue)
    â†“
  GCWebhook2: Trigger payment split
    â†“
  GCSplit1: Process payment split


2.4 Analysis: Should We Split GCWebhook?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Arguments FOR splitting:
  âœ… Resilience: Cloud Tasks retry ensures payment split eventually succeeds
  âœ… Performance: GCWebhook1 returns faster (doesn't wait for payment split)
  âœ… Monitoring: Separate service for payment split triggers
  âœ… Consistency: Matches GCSplit pattern

Arguments AGAINST splitting:
  âŒ Complexity: 2 services instead of 1, more code to maintain
  âŒ Latency: Payment split is delayed (asynchronous via Cloud Tasks)
  âŒ Minimal benefit: GCSplit1 should be highly available anyway
  âŒ No external API: Payment split webhook calls internal service, not external
  âŒ Different failure mode: GCSplit was split to handle ChangeNow downtime
     (external API that goes down). GCSplit1 is our own service, shouldn't go down.
  âŒ User experience: Payment split delay might cause confusion

RECOMMENDATION: DO NOT SPLIT GCWebhook

Reasoning:
  1. The payment split webhook calls an INTERNAL service (GCSplit1), not an
     external API prone to downtime like ChangeNow.

  2. If GCSplit1 is down, we have bigger problems (the entire payment system
     is down). Splitting GCWebhook won't fix this.

  3. GCSplit was split specifically to handle EXTERNAL API downtime (ChangeNow).
     That's not the case here.

  4. The added complexity (2 services, encryption, Cloud Tasks queue) outweighs
     the minimal resilience benefit.

  5. If we want resilience against GCSplit1 downtime, we should focus on making
     GCSplit1 highly available (autoscaling, health checks, multiple instances).

Alternative: Add Retry Logic Without Splitting
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Instead of splitting, we could add simple retry logic to the payment split
webhook trigger:

def trigger_payment_split_webhook(...):
    max_retries = 3
    retry_delay = 5  # seconds

    for attempt in range(max_retries):
        try:
            response = requests.post(webhook_url, ...)
            if response.status_code == 200:
                return True
        except Exception as e:
            if attempt < max_retries - 1:
                time.sleep(retry_delay)
                continue

    return False

This provides basic resilience without the complexity of splitting into
separate services.

================================================================================
SECTION 3: GCHOSTPAY10-26 DETAILED ANALYSIS
================================================================================

3.1 Current Architecture
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GCHostPay is a Flask service with integrated modules for Web3 operations.

Flow Diagram:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ POST / with JSON payload: { "token": "<encrypted_token>" }               â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 1. Fetch TPS HostPay signing key from Secret Manager                     â”‚
  â”‚    Dependencies: Google Cloud Secret Manager                             â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 2. Decode and verify HostPay token                                       â”‚
  â”‚    Function: decode_and_verify_hostpay_token()                           â”‚
  â”‚    Token format: unique_id, cn_api_id, from_currency, from_network,      â”‚
  â”‚                  from_amount, payin_address, timestamp                    â”‚
  â”‚    Token expiration: 1 minute (60 seconds)                               â”‚
  â”‚    Dependencies: LOCAL (no external API)                                 â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 3. Check if transaction already processed                                â”‚
  â”‚    Function: db_manager.check_transaction_exists(unique_id)              â”‚
  â”‚    Table: hostpay_transactions                                           â”‚
  â”‚    Purpose: Prevent duplicate payments (idempotency)                     â”‚
  â”‚    Dependencies: Cloud SQL PostgreSQL                                    â”‚
  â”‚    Failure Mode: Database error â†’ HTTP 500                               â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 4. Check ChangeNow transaction status                                    â”‚
  â”‚    Function: check_changenow_status(cn_api_id)                           â”‚
  â”‚    API: GET https://api.changenow.io/v2/exchange/by-id?id={cn_api_id}   â”‚
  â”‚    Expected status: "waiting"                                            â”‚
  â”‚    Timeout: 30 seconds                                                   â”‚
  â”‚    Dependencies: ChangeNow API â† EXTERNAL, PRONE TO DOWNTIME             â”‚
  â”‚    Failure Modes:                                                        â”‚
  â”‚      - ChangeNow API down â†’ HTTP 500                                     â”‚
  â”‚      - Network timeout â†’ HTTP 500                                        â”‚
  â”‚      - Wrong status (not "waiting") â†’ HTTP 400, stop execution           â”‚
  â”‚    CRITICAL: Must verify "waiting" before sending ETH to avoid loss      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 5. Execute ETH payment                                                   â”‚
  â”‚    Function: wallet_manager.send_eth_payment()                           â”‚
  â”‚    Dependencies: Alchemy RPC API â† EXTERNAL, GENERALLY RELIABLE          â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼ (Detailed sub-flow below)


ETH Payment Sub-Flow (wallet_manager.send_eth_payment):
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 5a. Connect to Web3 provider (Alchemy)                                   â”‚
  â”‚     Function: _connect_to_web3()                                         â”‚
  â”‚     Alchemy RPC URL: fetched from Secret Manager                         â”‚
  â”‚     Dependencies: Alchemy RPC endpoint                                   â”‚
  â”‚     Failure Mode: Connection error â†’ return None                         â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 5b. Call _send_transaction_with_retry() [MAX 3 ATTEMPTS]                 â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ RETRY LOOP (Attempt 1/3, 2/3, 3/3)                                       â”‚
  â”‚                                                                           â”‚
  â”‚   5c. Get nonce                                                           â”‚
  â”‚       Function: w3.eth.get_transaction_count()                           â”‚
  â”‚       Alchemy API call                                                   â”‚
  â”‚                                                                           â”‚
  â”‚   5d. Get optimized gas prices                                           â”‚
  â”‚       Function: _get_optimized_gas_price()                               â”‚
  â”‚       - Fetch fee_history (base fee + priority fee)                      â”‚
  â”‚       - Calculate EIP-1559 gas prices                                    â”‚
  â”‚       Alchemy API call                                                   â”‚
  â”‚                                                                           â”‚
  â”‚   5e. Build transaction                                                  â”‚
  â”‚       EIP-1559 format: nonce, to, value, gas, maxFeePerGas,              â”‚
  â”‚                        maxPriorityFeePerGas, chainId                     â”‚
  â”‚                                                                           â”‚
  â”‚   5f. Sign transaction                                                   â”‚
  â”‚       LOCAL operation (uses private key)                                 â”‚
  â”‚                                                                           â”‚
  â”‚   5g. Broadcast transaction                                              â”‚
  â”‚       Function: w3.eth.send_raw_transaction()                            â”‚
  â”‚       Alchemy API call                                                   â”‚
  â”‚       Returns: tx_hash                                                   â”‚
  â”‚                                                                           â”‚
  â”‚   5h. Wait for confirmation (300s timeout)                               â”‚
  â”‚       Function: w3.eth.wait_for_transaction_receipt()                    â”‚
  â”‚       Alchemy API call (polls for receipt)                               â”‚
  â”‚       Failure scenarios:                                                 â”‚
  â”‚         - Timeout (300s) â†’ check if pending, try to replace              â”‚
  â”‚         - Transaction failed on-chain â†’ retry (if attempts remaining)    â”‚
  â”‚         - Transaction stuck â†’ call _replace_stuck_transaction()          â”‚
  â”‚                                                                           â”‚
  â”‚   If transaction stuck:                                                  â”‚
  â”‚     5i. Replace stuck transaction                                        â”‚
  â”‚         Function: _replace_stuck_transaction()                           â”‚
  â”‚         - Get new gas prices (20% higher)                                â”‚
  â”‚         - Build replacement tx with same nonce                           â”‚
  â”‚         - Broadcast replacement                                          â”‚
  â”‚         - Wait for confirmation (300s timeout)                           â”‚
  â”‚                                                                           â”‚
  â”‚   If attempt fails and retries remain:                                   â”‚
  â”‚     - Sleep 10 seconds                                                   â”‚
  â”‚     - Continue to next attempt                                           â”‚
  â”‚                                                                           â”‚
  â”‚   Special error handling:                                                â”‚
  â”‚     - "nonce too low" â†’ don't retry (tx already mined)                   â”‚
  â”‚     - "insufficient funds" â†’ don't retry (not enough ETH)                â”‚
  â”‚     - "replacement underpriced" â†’ increase gas buffer by 10%             â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 5j. Return transaction result                                            â”‚
  â”‚     {                                                                     â”‚
  â”‚       "tx_hash": "0x...",                                                 â”‚
  â”‚       "status": "success" | "failed",                                     â”‚
  â”‚       "gas_used": int,                                                    â”‚
  â”‚       "block_number": int                                                 â”‚
  â”‚     }                                                                     â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 6. Log transaction to database                                           â”‚
  â”‚    Function: db_manager.insert_hostpay_transaction()                     â”‚
  â”‚    Table: hostpay_transactions                                           â”‚
  â”‚    Fields: unique_id, cn_api_id, from_currency, from_network,            â”‚
  â”‚            from_amount, payin_address, is_complete, tx_hash, tx_status,  â”‚
  â”‚            gas_used, block_number                                        â”‚
  â”‚    Dependencies: Cloud SQL PostgreSQL                                    â”‚
  â”‚    Failure Mode: Non-fatal - payment succeeded, logging failed           â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 7. Return 200 OK                                                         â”‚
  â”‚    Response: { "status": "success", "data": {...} }                      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


3.2 Potential Breakdown Points
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Analyzing each step for potential failure scenarios:

Step 1: Fetch signing key from Secret Manager
  - Failure scenario: Secret Manager down (extremely rare)
  - Impact: HTTP 500, entire request fails
  - Mitigation: Secret Manager has 99.95% SLA, can cache at startup
  - Should we split? NO - infrastructure dependency

Step 2: Decode and verify token
  - Failure scenario: Invalid token, signature mismatch, expired token (>1 min)
  - Impact: HTTP 400, request rejected (expected behavior)
  - Should we split? NO - local operation, input validation

Step 3: Check if already processed
  - Failure scenario: Database connection error, query timeout
  - Impact: HTTP 500, request fails
  - Mitigation: Connection pooling, transient error retry
  - Should we split? NO - database is reliable, not the bottleneck

Step 4: Check ChangeNow status â† CRITICAL EXTERNAL DEPENDENCY
  - Failure scenarios:
    âœ— ChangeNow API down (504 Gateway Timeout)
    âœ— ChangeNow API overloaded (503 Service Unavailable)
    âœ— Network timeout (30 seconds)
    âœ— Connection error
    âœ— API returns wrong status (not "waiting")

  - Impact:
    âœ— HTTP 500, payment fails completely
    âœ— User's payment is lost (they paid, but we didn't send ETH to ChangeNow)

  - Current behavior:
    âœ— Single API call with 30s timeout
    âœ— No retry logic
    âœ— If ChangeNow is down, payment fails immediately

  - Should we split? MAYBE - this is the primary candidate for splitting

  - Analysis:
    ğŸ” CRITICAL REQUIREMENT: We MUST verify status is "waiting" before sending ETH
    ğŸ” If we send ETH to ChangeNow when status is NOT "waiting", we lose money
    ğŸ” ChangeNow has documented downtime (as noted in previous conversations)
    ğŸ” Current implementation is fragile: One API failure = entire payment fails

  - Splitting benefits:
    âœ… Cloud Tasks infinite retry (up to 24 hours)
    âœ… Exponential backoff
    âœ… If ChangeNow is down for 30 minutes, payment still succeeds

  - Splitting risks:
    âš ï¸  ChangeNow transactions have expiration times
    âš ï¸  If we retry for 24 hours, transaction might expire
    âš ï¸  Expired transactions can't receive payments (ETH would be lost)

  - Timing consideration:
    The ChangeNow transaction was created by GCSplit3
    GCSplit3 uses flow="standard" and type_="direct"
    ChangeNow standard transactions typically have:
      - Deposit time: 2-6 hours
      - Total time: 2-24 hours

    So retrying for up to 24 hours MIGHT work, but it's cutting it close.
    Need to verify ChangeNow transaction expiration policy.

Step 5: Execute ETH payment â† EXTERNAL DEPENDENCY (GENERALLY RELIABLE)
  - Failure scenarios:
    âœ— Alchemy RPC down (extremely rare, 99.9%+ SLA)
    âœ— Network timeout (300s for confirmation)
    âœ— Gas price too low (transaction stuck in mempool)
    âœ— Nonce too low (transaction already mined)
    âœ— Insufficient funds (wallet empty)
    âœ— Transaction replaced (by another transaction with same nonce)

  - Current mitigation:
    âœ… 3 retry attempts with 10s delay
    âœ… Transaction replacement logic (_replace_stuck_transaction)
    âœ… Gas price buffering (20% increase on replacement)
    âœ… Special error handling (nonce errors, insufficient funds)
    âœ… 300s timeout for confirmation

  - Impact:
    âœ— HTTP 500, payment fails
    âœ— But if ChangeNow status was "waiting", we can retry safely

  - Should we split? DEBATABLE

  - Analysis:
    ğŸ” Alchemy RPC is very reliable (99.9%+ uptime, Tier 1 provider)
    ğŸ” Current retry logic (3 attempts) handles most transient failures
    ğŸ” Transaction replacement handles stuck transactions
    ğŸ” Most failures are due to gas prices or nonce issues, not Alchemy downtime

  - Splitting benefits:
    âœ… Could implement longer retry period (beyond 3 attempts)
    âœ… Cloud Tasks automatic retry with exponential backoff

  - Splitting risks:
    âš ï¸  Adds latency (each retry is async via Cloud Tasks)
    âš ï¸  More complex error handling
    âš ï¸  Current internal retry (3 attempts, 10s delay) is ~30 seconds total
        Cloud Tasks retry could take minutes/hours
    âš ï¸  User expectation: Fast payment (seconds, not minutes)

Step 6: Log to database
  - Failure scenario: Database error
  - Impact: Non-fatal (payment succeeded, logging failed)
  - Should we split? NO - non-critical operation


3.3 Potential Split Architectures
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Option 1: Split ChangeNow Status Check Only
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

GCHostPay1-10-26: Main Service
  Endpoints: 3
    - POST / (hostpay_webhook)
    - POST /alchemy-webhook (alchemy_webhook)
    - GET /health (health_check)

  Workflow:
    1. Decode and verify token
    2. Check if already processed (database)
    3. Enqueue Cloud Task to GCHostPay2 (status check)
    4. [Wait for callback from GCHostPay2]

  Note: This creates a problem - GCHostPay1 would need to return a response
  before the payment is complete, OR implement a callback mechanism.

GCHostPay2-10-26: ChangeNow Status Checker
  Endpoints: 1
    - POST / (check_status)

  Workflow:
    1. Receive encrypted token from GCHostPay1
    2. Decrypt token
    3. Call ChangeNow status check API (with retry)
    4. If status != "waiting", return error
    5. Enqueue Cloud Task back to GCHostPay1 with status result

  Benefits:
    âœ… Isolates ChangeNow API downtime
    âœ… Infinite retry via Cloud Tasks

  Drawbacks:
    âŒ Complex callback mechanism needed
    âŒ GCHostPay1 needs to handle async responses
    âŒ Adds latency

Modified Option 1: ChangeNow Status Check with Direct ETH Payment
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

GCHostPay1-10-26: Orchestrator
  Endpoints: 3
    - POST / (hostpay_webhook) - Initial entry point
    - POST /continue-payment (continue_payment) - Callback from GCHostPay2
    - POST /alchemy-webhook (alchemy_webhook)
    - GET /health (health_check)

  Workflow (Initial):
    1. Decode and verify token
    2. Check if already processed (database)
    3. Enqueue Cloud Task to GCHostPay2 (status check)
    4. Return 200 OK (async processing)

  Workflow (Callback):
    1. Receive encrypted token from GCHostPay2
    2. Decrypt token (includes status result)
    3. Execute ETH payment (wallet_manager)
    4. Log to database
    5. Return 200 OK

GCHostPay2-10-26: ChangeNow Status Checker
  Endpoints: 1
    - POST / (check_status)

  Workflow:
    1. Receive encrypted token from GCHostPay1
    2. Decrypt token
    3. Call ChangeNow status check API (with infinite retry)
    4. If status != "waiting", log error and return (stop processing)
    5. If status == "waiting", enqueue Cloud Task to GCHostPay1 /continue-payment
    6. Return 200 OK

  Benefits:
    âœ… Isolates ChangeNow API downtime
    âœ… Infinite retry via Cloud Tasks (up to 24 hours)
    âœ… Payment proceeds immediately after status check succeeds

  Drawbacks:
    âŒ Adds complexity (2 services, callback endpoint)
    âŒ Adds latency (async processing)
    âŒ Risk of ChangeNow transaction expiration during retry period

Flow Diagram (Option 1 Modified):
  GCSplit1 â†’ Cloud Tasks (hostpay_queue)
    â†“
  GCHostPay1 / (initial)
    â†“
  Cloud Tasks (changenow_status_queue)
    â†“
  GCHostPay2 / (status check with retry)
    â†“
  Cloud Tasks (hostpay_continue_queue)
    â†“
  GCHostPay1 /continue-payment (ETH payment)


Option 2: Full Split (Like GCSplit Pattern)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

GCHostPay1-10-26: Orchestrator
  Endpoints: 3
    - POST / (hostpay_webhook) - Initial entry point
    - POST /status-result (receive_status_result) - Callback from GCHostPay2
    - POST /payment-result (receive_payment_result) - Callback from GCHostPay3
    - POST /alchemy-webhook (alchemy_webhook)
    - GET /health (health_check)

  Workflow (Initial):
    1. Decode and verify token
    2. Check if already processed (database)
    3. Enqueue Cloud Task to GCHostPay2 (status check)
    4. Return 200 OK (async processing)

  Workflow (Status Result Callback):
    1. Receive encrypted token from GCHostPay2
    2. Decrypt token (includes status)
    3. If status != "waiting", return error
    4. Enqueue Cloud Task to GCHostPay3 (ETH payment)
    5. Return 200 OK

  Workflow (Payment Result Callback):
    1. Receive encrypted token from GCHostPay3
    2. Decrypt token (includes tx_hash, status)
    3. Log to database
    4. Return 200 OK

GCHostPay2-10-26: ChangeNow Status Checker
  Endpoints: 1
    - POST / (check_status)

  Workflow:
    1. Receive encrypted token from GCHostPay1
    2. Decrypt token
    3. Call ChangeNow status check API (with infinite retry)
    4. Encrypt response token with status result
    5. Enqueue Cloud Task to GCHostPay1 /status-result
    6. Return 200 OK

GCHostPay3-10-26: ETH Payment Executor
  Endpoints: 1
    - POST / (execute_payment)

  Workflow:
    1. Receive encrypted token from GCHostPay1
    2. Decrypt token
    3. Execute ETH payment (with infinite retry via Cloud Tasks)
       - If transaction fails, retry via Cloud Tasks (not internal retry)
    4. Encrypt response token with payment result
    5. Enqueue Cloud Task to GCHostPay1 /payment-result
    6. Return 200 OK

  Benefits:
    âœ… Maximum resilience - both external APIs isolated
    âœ… Infinite retry for both ChangeNow and Alchemy APIs
    âœ… Consistent with GCSplit pattern

  Drawbacks:
    âŒ Most complex option (3 services)
    âŒ Significant latency (multiple async hops)
    âŒ Risk of ChangeNow transaction expiration
    âŒ User expectation: Fast payment (seconds, not minutes/hours)
    âŒ Over-engineering: Alchemy is very reliable (99.9%+ SLA)

Flow Diagram (Option 2 Full Split):
  GCSplit1 â†’ Cloud Tasks
    â†“
  GCHostPay1 / (initial)
    â†“
  Cloud Tasks
    â†“
  GCHostPay2 / (status check)
    â†“
  Cloud Tasks
    â†“
  GCHostPay1 /status-result
    â†“
  Cloud Tasks
    â†“
  GCHostPay3 / (ETH payment)
    â†“
  Cloud Tasks
    â†“
  GCHostPay1 /payment-result (log DB)


Option 3: No Split, Enhanced Retry Logic
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Keep GCHostPay as a single service, but enhance retry logic:

GCHostPay10-26: Enhanced Monolith
  Endpoints: 3 (unchanged)
    - POST / (hostpay_webhook)
    - POST /alchemy-webhook (alchemy_webhook)
    - GET /health (health_check)

  Enhancements:
    1. ChangeNow status check:
       - Add retry loop: 5 attempts with exponential backoff
       - Total retry time: ~2-3 minutes
       - If ChangeNow down for >3 minutes, return HTTP 500
         (let Cloud Tasks at caller level retry the entire request)

    2. ETH payment:
       - Keep existing retry logic (3 attempts)
       - Keep transaction replacement logic

    3. Add idempotency:
       - Check if already processed at start (already implemented)
       - Safe to retry entire request if it fails

  Benefits:
    âœ… Simple - no architectural changes
    âœ… Better retry logic than current (single attempt)
    âœ… No latency increase
    âœ… Leverages Cloud Tasks retry at GCSplit1 â†’ GCHostPay level

  Drawbacks:
    âŒ Not as resilient as splitting
    âŒ Limited retry window (2-3 minutes vs 24 hours)
    âŒ If ChangeNow down for >3 minutes, still fails

Code Changes (Option 3):
  def check_changenow_status(cn_api_id: str) -> Optional[str]:
      max_retries = 5
      retry_delays = [5, 10, 20, 40, 60]  # Exponential backoff

      for attempt in range(max_retries):
          try:
              # Existing API call code...
              if response.status_code == 200:
                  return status
          except Exception as e:
              if attempt < max_retries - 1:
                  time.sleep(retry_delays[attempt])
                  continue

      return None  # All retries failed


3.4 Analysis: Should We Split GCHostPay?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Key Considerations:
  1. ChangeNow API downtime is documented (previous conversations)
  2. Alchemy RPC is very reliable (99.9%+ SLA, Tier 1 provider)
  3. ChangeNow transactions have expiration times
  4. Current internal retry (3 attempts for ETH, 0 attempts for ChangeNow status)
  5. User expectation: Fast payment (seconds, not minutes)

Arguments FOR splitting (Option 1 or 2):
  âœ… Isolates ChangeNow API downtime (primary external dependency)
  âœ… Infinite retry via Cloud Tasks (up to 24 hours)
  âœ… Consistent with GCSplit pattern (architectural consistency)
  âœ… Better monitoring (separate service for status checks)
  âœ… If ChangeNow down for 30-60 minutes, payment still succeeds

Arguments AGAINST splitting:
  âŒ Adds significant complexity (2-3 services vs 1)
  âŒ Adds latency (async processing via Cloud Tasks)
  âŒ Risk of ChangeNow transaction expiration during long retry periods
  âŒ Over-engineering: Most failures are transient (<5 minutes)
  âŒ Current internal retry can be enhanced without splitting (Option 3)
  âŒ User experience: Payment delay might cause confusion
  âŒ Alchemy RPC is very reliable, doesn't need infinite retry

RECOMMENDATION: ENHANCED RETRY LOGIC (OPTION 3) AS FIRST STEP

Reasoning:
  1. Most ChangeNow API failures are transient (<5 minutes)
  2. Adding a 5-attempt retry loop with exponential backoff handles 90%+ of cases
  3. Total retry time: ~2-3 minutes (acceptable for user experience)
  4. If ChangeNow is down for >3 minutes, Cloud Tasks at caller level
     (GCSplit1 â†’ GCHostPay) will retry the entire request
  5. Much simpler than splitting (no architectural changes)
  6. Can be implemented quickly

ALTERNATIVE RECOMMENDATION: SPLIT CHANGENOW STATUS CHECK (OPTION 1) IF:
  - ChangeNow downtime exceeds 5 minutes frequently (need to monitor)
  - Enhanced retry logic (Option 3) proves insufficient
  - Business requirements demand maximum resilience

Implementation Priority:
  1. Implement Option 3 (Enhanced Retry Logic) - LOW COMPLEXITY, QUICK WIN
  2. Monitor ChangeNow API reliability for 1-2 weeks
  3. If downtime >5 minutes is frequent, consider Option 1 (Split Status Check)

DO NOT RECOMMEND: Option 2 (Full Split)
  - Over-engineering for Alchemy RPC (already very reliable)
  - Too much complexity, latency, and risk for minimal benefit

================================================================================
SECTION 4: CHANGENOW TRANSACTION EXPIRATION ANALYSIS
================================================================================

Critical Question: How long do ChangeNow transactions stay in "waiting" status
before they expire?

This is crucial for determining whether infinite retry (24 hours) is safe.

From ChangeNow Documentation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Flow: "standard"
  - Deposit time: 2-6 hours (typical)
  - Transaction can be in "waiting" status for up to 2-6 hours
  - After this period, if no deposit received, status changes to "expired"

Flow: "fixed-rate"
  - Rate is locked for a specific time period (varies by currency pair)
  - Typically 10-20 minutes for ETH pairs
  - After rate lock expires, transaction may be cancelled or repriced

Our Usage (from GCSplit3):
  flow="standard"
  type_="direct"

Implication:
  âœ… Standard flow transactions have 2-6 hour "waiting" window
  âœ… Infinite retry (up to 24 hours) is likely safe
  âš ï¸  BUT: If ChangeNow is down for >2 hours, transaction might expire
  âš ï¸  Need to monitor ChangeNow downtime duration

Recommendation:
  - If splitting, set Cloud Tasks retry max duration to 2 hours (not 24)
  - This ensures we retry during the "waiting" window
  - After 2 hours, if still failing, give up (transaction likely expired)

================================================================================
SECTION 5: FINAL RECOMMENDATIONS
================================================================================

5.1 GCWebhook10-26
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RECOMMENDATION: DO NOT SPLIT

Rationale:
  - Payment split webhook calls internal service (GCSplit1), not external API
  - Splitting adds complexity with minimal resilience benefit
  - Focus on making GCSplit1 highly available instead

Optional Enhancement:
  - Add simple retry logic (3 attempts, 5s delay) to payment split webhook
  - This provides basic resilience without splitting architecture

Implementation:
  NO CHANGES REQUIRED - keep current architecture


5.2 GCHostPay10-26
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RECOMMENDATION: ENHANCED RETRY LOGIC (SHORT-TERM)

Rationale:
  - ChangeNow API is the primary external dependency with documented downtime
  - Most failures are transient (<5 minutes)
  - Enhanced retry logic handles 90%+ of cases without architectural changes
  - Simpler, faster to implement, lower risk

Implementation (Option 3 - Enhanced Retry Logic):
  Step 1: Add retry logic to check_changenow_status()
    - 5 attempts with exponential backoff: 5s, 10s, 20s, 40s, 60s
    - Total retry time: ~2-3 minutes
    - If all retries fail, return None (HTTP 500)

  Step 2: Add retry logic to Alchemy RPC operations (optional)
    - Current: 3 attempts with 10s delay (already implemented)
    - No changes needed (already robust)

  Step 3: Monitor ChangeNow API reliability
    - Track downtime frequency and duration
    - If downtime >5 minutes is frequent, revisit splitting decision

Pseudo-code:
  def check_changenow_status_with_retry(cn_api_id: str) -> Optional[str]:
      max_retries = 5
      retry_delays = [5, 10, 20, 40, 60]  # seconds

      for attempt in range(max_retries):
          try:
              print(f"ğŸ” [CHANGENOW_STATUS] Attempt {attempt + 1}/{max_retries}")
              status = check_changenow_status(cn_api_id)

              if status:
                  print(f"âœ… [CHANGENOW_STATUS] Status check succeeded: {status}")
                  return status

              print(f"âŒ [CHANGENOW_STATUS] Status check failed (returned None)")

              if attempt < max_retries - 1:
                  delay = retry_delays[attempt]
                  print(f"â³ [CHANGENOW_STATUS] Retrying in {delay}s...")
                  time.sleep(delay)

          except Exception as e:
              print(f"âŒ [CHANGENOW_STATUS] Exception: {e}")

              if attempt < max_retries - 1:
                  delay = retry_delays[attempt]
                  print(f"â³ [CHANGENOW_STATUS] Retrying in {delay}s...")
                  time.sleep(delay)

      print(f"âŒ [CHANGENOW_STATUS] All {max_retries} attempts failed")
      return None


ALTERNATIVE RECOMMENDATION: SPLIT CHANGENOW STATUS CHECK (LONG-TERM)

If monitoring shows ChangeNow downtime >5 minutes is frequent:
  - Implement Option 1 (Modified): Split ChangeNow Status Check
  - Use Cloud Tasks with 2-hour max retry duration (not 24 hours)
  - This ensures retry stays within ChangeNow transaction "waiting" window

Implementation (Option 1 - Split Status Check):
  Step 1: Create GCHostPay2-10-26 service
    - Single endpoint: POST / (check_status)
    - Receives encrypted token from GCHostPay1
    - Calls ChangeNow status check API
    - Returns encrypted response to GCHostPay1

  Step 2: Modify GCHostPay1-10-26
    - Add callback endpoint: POST /continue-payment
    - Initial webhook enqueues Cloud Task to GCHostPay2
    - Returns 200 OK (async processing)

  Step 3: Configure Cloud Tasks queue
    - Queue name: changenow_status_queue
    - Max retry duration: 2 hours (not 24 hours)
    - Exponential backoff: 10s min, 5min max

  Step 4: Create encryption/decryption for inter-service tokens
    - Reuse existing token_manager pattern from GCSplit

DO NOT RECOMMEND: Full Split (Option 2)
  - Over-engineering for Alchemy RPC (already 99.9%+ reliable)
  - Adds too much complexity and latency
  - User expectation: Fast payments (seconds, not minutes)

================================================================================
SECTION 6: IMPLEMENTATION CHECKLIST
================================================================================

6.1 GCWebhook10-26 (No Changes)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… No implementation required - keep current architecture

Optional Enhancement (if desired):
  â˜ Add retry logic to trigger_payment_split_webhook()
  â˜ Max 3 attempts, 5s delay between attempts
  â˜ Update logging to track retry attempts


6.2 GCHostPay10-26 (Enhanced Retry Logic)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Implementation Steps:

  â˜ Step 1: Backup current tphp10-26.py

  â˜ Step 2: Modify check_changenow_status() function
      â˜ Add retry loop (5 attempts)
      â˜ Add exponential backoff (5s, 10s, 20s, 40s, 60s)
      â˜ Add logging for each retry attempt
      â˜ Return None if all retries fail

  â˜ Step 3: Test retry logic locally
      â˜ Mock ChangeNow API failure
      â˜ Verify retry attempts work correctly
      â˜ Verify exponential backoff timing
      â˜ Verify total retry time is ~2-3 minutes

  â˜ Step 4: Deploy to Cloud Run
      â˜ Build Docker image
      â˜ Push to Container Registry
      â˜ Deploy to GCHostPay10-26 service

  â˜ Step 5: Monitor logs
      â˜ Watch for ChangeNow API failures
      â˜ Verify retry logic triggers correctly
      â˜ Track retry success rate

  â˜ Step 6: Monitor for 1-2 weeks
      â˜ Track ChangeNow API downtime frequency
      â˜ Track downtime duration (is it >5 minutes?)
      â˜ Decide if splitting is needed based on data

  â˜ Step 7: If downtime >5 minutes is frequent, implement Option 1 (Split)
      â˜ Create GCHostPay2-10-26 service
      â˜ Create changenow_status_queue Cloud Tasks queue
      â˜ Modify GCHostPay1 to use async workflow
      â˜ Set max retry duration to 2 hours (not 24)


6.3 GCHostPay10-26 Alternative (Split Status Check - if needed)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Only implement if monitoring shows ChangeNow downtime >5 minutes is frequent.

  â˜ Step 1: Create GCHostPay2-10-26 service
      â˜ Create new directory: GCHostPay2-10-26/
      â˜ Copy config_manager.py, token_manager.py (from GCSplit pattern)
      â˜ Create tphp2-10-26.py with single endpoint
      â˜ Create Dockerfile
      â˜ Add to requirements.txt: Flask, google-cloud-tasks, google-cloud-secret-manager

  â˜ Step 2: Create Cloud Tasks queue
      â˜ Queue name: changenow-status-queue
      â˜ Location: us-central1 (or your region)
      â˜ Max retry: 2 hours (7200 seconds)
      â˜ Min backoff: 10s
      â˜ Max backoff: 300s (5 minutes)

  â˜ Step 3: Modify GCHostPay1-10-26
      â˜ Add CloudTasksClient initialization
      â˜ Add callback endpoint: POST /continue-payment
      â˜ Modify main endpoint to enqueue Cloud Task to GCHostPay2
      â˜ Add token encryption for inter-service communication
      â˜ Return 200 OK immediately (async processing)

  â˜ Step 4: Deploy both services
      â˜ Deploy GCHostPay2-10-26 first
      â˜ Test GCHostPay2 endpoint independently
      â˜ Deploy GCHostPay1-10-26 updates
      â˜ Test end-to-end workflow

  â˜ Step 5: Monitor and validate
      â˜ Test with actual ChangeNow transactions
      â˜ Monitor Cloud Tasks queue
      â˜ Verify retry logic works during ChangeNow downtime
      â˜ Verify payments complete successfully after retries

================================================================================
SECTION 7: COMPARISON MATRIX
================================================================================

Feature                     | GCWebhook    | GCHostPay (Current) | GCHostPay (Enhanced) | GCHostPay (Split)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
External API Calls          | None         | 2 (CN, Alchemy)     | 2 (CN, Alchemy)      | 2 (CN, Alchemy)
ChangeNow API Retry         | N/A          | None (1 attempt)    | 5 attempts (3min)    | Infinite (2h max)
Alchemy RPC Retry           | N/A          | 3 attempts (30s)    | 3 attempts (30s)     | 3 or Infinite
Service Count               | 1            | 1                   | 1                    | 2-3
Complexity                  | Low          | Medium              | Medium               | High
Latency                     | Low          | Medium              | Medium               | High (async)
Resilience (CN downtime)    | N/A          | Low (single call)   | Medium (3min retry)  | High (2h retry)
Risk of TX Expiration       | N/A          | Low                 | Low                  | Medium
Implementation Effort       | None         | Current state       | 1-2 hours            | 2-3 days
Maintenance Burden          | Low          | Medium              | Medium               | High
Recommendation              | Keep as-is   | Short-term baseline | âœ… RECOMMENDED       | Optional long-term

================================================================================
SECTION 8: MONITORING REQUIREMENTS
================================================================================

To make an informed decision about splitting GCHostPay, we need to monitor:

8.1 ChangeNow API Metrics
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  â˜ Track ChangeNow API call success rate
  â˜ Track ChangeNow API downtime frequency (failures per day)
  â˜ Track ChangeNow API downtime duration (how long does it stay down?)
  â˜ Track ChangeNow API response times
  â˜ Track ChangeNow API error codes (504, 503, 500, etc.)

Key Question: How often is ChangeNow down for >5 minutes?
  - If rarely (< 1x per week): Enhanced retry logic (Option 3) is sufficient
  - If frequently (> 3x per week): Consider splitting (Option 1)

8.2 Alchemy RPC API Metrics
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  â˜ Track Alchemy RPC call success rate
  â˜ Track Alchemy RPC downtime (very rare)
  â˜ Track transaction confirmation times
  â˜ Track stuck transactions (requiring replacement)
  â˜ Track gas price optimization effectiveness

Key Question: Is Alchemy RPC reliability an issue?
  - Expected: 99.9%+ uptime (should NOT be an issue)
  - If Alchemy is unreliable, consider changing providers

8.3 GCHostPay Service Metrics
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  â˜ Track total payment requests
  â˜ Track successful payments
  â˜ Track failed payments (by failure reason)
  â˜ Track payment completion time (end-to-end latency)
  â˜ Track retry attempts (after enhanced retry logic implemented)

8.4 Cloud Tasks Metrics (if split)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  â˜ Track Cloud Tasks queue depth
  â˜ Track task retry counts
  â˜ Track task success/failure rates
  â˜ Track task execution latency

================================================================================
SECTION 9: CONCLUSION
================================================================================

Summary of Findings:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

GCWebhook10-26:
  âœ… DO NOT SPLIT
  - No external API calls prone to downtime
  - Calls internal service (GCSplit1), not external API
  - Splitting adds unnecessary complexity
  - Focus on making GCSplit1 highly available instead

GCHostPay10-26:
  âš ï¸  IMPLEMENT ENHANCED RETRY LOGIC FIRST (OPTION 3)
  - Short-term: Add 5-attempt retry loop with exponential backoff (2-3 min total)
  - Monitor ChangeNow API reliability for 1-2 weeks
  - Long-term: If ChangeNow downtime >5 minutes is frequent, consider splitting

  âŒ DO NOT implement full split (Option 2)
  - Over-engineering for Alchemy RPC (already 99.9%+ reliable)
  - Too much complexity, latency, and risk

Key Differences from GCSplit:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GCSplit was split because:
  âœ… Multiple ChangeNow API calls (estimate + create transaction)
  âœ… ChangeNow API has documented downtime
  âœ… Payment flow is asynchronous by nature (user waits for invite)
  âœ… Transaction expiration window is long (2-6 hours)
  âœ… Infinite retry (24 hours) is safe

GCHostPay is different because:
  âš ï¸  Only ONE ChangeNow API call (status check)
  âš ï¸  Alchemy RPC is very reliable (99.9%+ SLA)
  âš ï¸  User expectation: Fast payment (seconds, not minutes)
  âš ï¸  Enhanced retry logic handles 90%+ of transient failures
  âš ï¸  Splitting adds complexity for minimal incremental benefit

Recommended Approach:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Keep GCWebhook as-is (no split)
2. Enhance GCHostPay retry logic (Option 3) - QUICK WIN
3. Monitor ChangeNow API reliability for 1-2 weeks
4. If monitoring shows frequent downtimes >5 minutes, revisit splitting decision
5. If splitting becomes necessary, use Option 1 (split ChangeNow status only)
6. Set Cloud Tasks max retry to 2 hours (not 24) to avoid transaction expiration

This approach balances resilience, complexity, and user experience while
maintaining a pragmatic, data-driven approach to architecture decisions.

================================================================================
END OF ANALYSIS
================================================================================
