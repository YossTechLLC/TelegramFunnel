================================================================================
GCREGISTER SECURITY ENHANCEMENTS (OPTIONAL)
Production-Ready Security Features for Custom Domain
================================================================================

File: GCRegister10-26/tpr10-26.py
Purpose: Add production security enhancements for www.paygateprime.com
Status: OPTIONAL - Your app works fine without these, but they're recommended
Date: 2025-10-27

================================================================================
IMPORTANT NOTES
================================================================================

‚úÖ Your GCRegister10-26 service will work perfectly with the custom domain
   WITHOUT any code changes.

‚úÖ These enhancements are OPTIONAL but RECOMMENDED for production security.

‚úÖ Implement these enhancements AFTER successfully mapping the domain and
   verifying everything works.

‚úÖ Each enhancement is independent - you can implement some or all of them.

================================================================================
ENHANCEMENT 1: SESSION COOKIE SECURITY
================================================================================

Purpose: Secure session cookies against common attacks
Benefits:
- Prevents cookie theft over HTTP (Secure flag)
- Prevents XSS attacks (HttpOnly flag)
- Prevents CSRF attacks (SameSite flag)
- Allows cookies across subdomains

Location: After line 24 in tpr10-26.py
Insert after: app.config['WTF_CSRF_ENABLED'] = True

Code to add:
--------------------------------------------------------------------------------

# ============================================================================
# SESSION COOKIE SECURITY (Production)
# ============================================================================
# Configure secure session cookies for production use with custom domain
app.config['SESSION_COOKIE_SECURE'] = True  # Only send over HTTPS
app.config['SESSION_COOKIE_HTTPONLY'] = True  # Prevent XSS attacks
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'  # Prevent CSRF attacks
app.config['SESSION_COOKIE_DOMAIN'] = '.paygateprime.com'  # Allow subdomains
app.config['PERMANENT_SESSION_LIFETIME'] = 3600  # 1 hour session timeout
print("üîí [APP] Session cookie security configured for production")


After implementation, your app.config section should look like:
--------------------------------------------------------------------------------

# Configure Flask app
app.config['SECRET_KEY'] = config['secret_key']
app.config['WTF_CSRF_ENABLED'] = True

# SESSION COOKIE SECURITY (Production)
app.config['SESSION_COOKIE_SECURE'] = True
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
app.config['SESSION_COOKIE_DOMAIN'] = '.paygateprime.com'
app.config['PERMANENT_SESSION_LIFETIME'] = 3600
print("üîí [APP] Session cookie security configured for production")


Testing:
1. Deploy the updated code
2. Visit https://www.paygateprime.com
3. Open browser DevTools (F12) ‚Üí Application ‚Üí Cookies
4. Verify session cookie has:
   - Secure: ‚úì
   - HttpOnly: ‚úì
   - SameSite: Lax


================================================================================
ENHANCEMENT 2: SECURITY HEADERS
================================================================================

Purpose: Add HTTP security headers to all responses
Benefits:
- Prevents clickjacking attacks
- Prevents MIME-sniffing attacks
- Enforces HTTPS usage
- Prevents XSS attacks
- Controls information leakage

Location: After app initialization (around line 32)
Insert after: db_manager = None

Code to add:
--------------------------------------------------------------------------------

# ============================================================================
# SECURITY HEADERS MIDDLEWARE
# ============================================================================

@app.after_request
def add_security_headers(response):
    """
    Add security headers to all HTTP responses.

    Headers added:
    - X-Content-Type-Options: Prevents MIME-sniffing
    - X-Frame-Options: Prevents clickjacking
    - X-XSS-Protection: Prevents XSS attacks (legacy support)
    - Strict-Transport-Security: Enforces HTTPS
    - Referrer-Policy: Controls referrer information
    - Content-Security-Policy: Restricts resource loading (optional, see below)
    """
    # Prevent MIME-sniffing attacks
    response.headers['X-Content-Type-Options'] = 'nosniff'

    # Prevent clickjacking attacks
    response.headers['X-Frame-Options'] = 'DENY'

    # Enable XSS protection (legacy browsers)
    response.headers['X-XSS-Protection'] = '1; mode=block'

    # Enforce HTTPS for 1 year, including all subdomains
    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'

    # Control referrer information leakage
    response.headers['Referrer-Policy'] = 'strict-origin-when-cross-origin'

    # Permissions policy (restrict browser features)
    response.headers['Permissions-Policy'] = 'geolocation=(), microphone=(), camera=()'

    print(f"üõ°Ô∏è  [SECURITY] Security headers added to response: {request.path}")
    return response

print("‚úÖ [APP] Security headers middleware configured")


Optional: Content Security Policy (CSP)
--------------------------------------------------------------------------------
CSP is powerful but can break functionality if not configured correctly.
Only add this after testing thoroughly.

Add to the add_security_headers function (after other headers):

    # Content Security Policy (ADVANCED - test thoroughly before enabling)
    csp = (
        "default-src 'self'; "
        "script-src 'self' 'unsafe-inline'; "  # Allow inline scripts (for CAPTCHA)
        "style-src 'self' 'unsafe-inline'; "   # Allow inline styles
        "img-src 'self' data: https:; "        # Allow images from self and https
        "font-src 'self'; "
        "connect-src 'self'; "
        "frame-ancestors 'none'; "             # Same as X-Frame-Options: DENY
        "base-uri 'self'; "
        "form-action 'self'"
    )
    response.headers['Content-Security-Policy'] = csp


Testing:
1. Deploy the updated code
2. Visit https://www.paygateprime.com
3. Open browser DevTools (F12) ‚Üí Network
4. Select any request ‚Üí Headers ‚Üí Response Headers
5. Verify presence of:
   - X-Content-Type-Options: nosniff
   - X-Frame-Options: DENY
   - X-XSS-Protection: 1; mode=block
   - Strict-Transport-Security: max-age=31536000; includeSubDomains
   - Referrer-Policy: strict-origin-when-cross-origin

6. Test site functionality:
   - Form submission works
   - CAPTCHA works
   - CSS loads correctly
   - JavaScript functions properly

7. Online checker: https://securityheaders.com/?q=www.paygateprime.com


================================================================================
ENHANCEMENT 3: HOST VALIDATION (DNS REBINDING PROTECTION)
================================================================================

Purpose: Validate request hostname to prevent DNS rebinding attacks
Benefits:
- Prevents malicious DNS rebinding
- Ensures traffic only comes through approved domains
- Protects against host header injection

Location: After security headers middleware (around line 60)

Code to add:
--------------------------------------------------------------------------------

# ============================================================================
# HOST VALIDATION MIDDLEWARE
# ============================================================================

# List of allowed hostnames (domains that can access this service)
ALLOWED_HOSTS = [
    'www.paygateprime.com',
    'paygateprime.com',  # Root domain
    'gcregister10-26-291176869049.us-central1.run.app',  # Keep for health checks
    'localhost',  # For local testing
    '127.0.0.1'   # For local testing
]

@app.before_request
def validate_host():
    """
    Validate the request hostname against allowed hosts.

    This prevents DNS rebinding attacks and ensures traffic only comes
    through approved domains.

    Exceptions:
    - /health endpoint (for Cloud Run health checks)
    - Localhost requests (for development)
    """
    # Allow health checks without host validation
    if request.path == '/health':
        return None

    # Get request host (includes port if present)
    request_host = request.host.split(':')[0]  # Remove port if present

    # Validate against allowed hosts
    if request_host not in ALLOWED_HOSTS:
        print(f"‚ö†Ô∏è  [SECURITY] Blocked request from invalid host: {request_host}")
        print(f"üîç [SECURITY] Allowed hosts: {', '.join(ALLOWED_HOSTS)}")
        print(f"üìç [SECURITY] Request path: {request.path}")
        print(f"üåê [SECURITY] Request IP: {request.remote_addr}")

        # Return 403 Forbidden
        abort(403, "Access denied: Invalid host")

    return None

print(f"‚úÖ [APP] Host validation configured for: {', '.join(ALLOWED_HOSTS)}")


Testing:
1. Deploy the updated code
2. Test valid domains:
   - https://www.paygateprime.com ‚Üí Should work ‚úÖ
   - https://paygateprime.com ‚Üí Should work ‚úÖ
   - https://gcregister10-26-291176869049.us-central1.run.app ‚Üí Should work ‚úÖ

3. Test health endpoint (should work without host validation):
   - https://www.paygateprime.com/health ‚Üí Should work ‚úÖ

4. Monitor logs for any blocked requests:
   gcloud logging read "resource.type=cloud_run_revision" --limit 50


‚ö†Ô∏è  IMPORTANT: After implementing host validation
--------------------------------------------------------------------------------
If you add subdomains in the future (e.g., api.paygateprime.com), remember to
add them to the ALLOWED_HOSTS list.


================================================================================
ENHANCEMENT 4: CANONICAL URL META TAG (SEO)
================================================================================

Purpose: Tell search engines the preferred URL for each page
Benefits:
- Prevents duplicate content issues
- Consolidates SEO value to www subdomain
- Improves search engine ranking

Location: /GCRegister10-26/templates/base.html

Find the <head> section and add:
--------------------------------------------------------------------------------

Current base.html <head> section (approximate location):
```html
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Channel Registration{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
```

Add this line before the closing </head> tag:
```html
    <!-- Canonical URL for SEO -->
    <link rel="canonical" href="https://www.paygateprime.com{{ request.path }}" />
</head>
```


Complete updated <head> section:
```html
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Channel Registration{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">

    <!-- Canonical URL for SEO -->
    <link rel="canonical" href="https://www.paygateprime.com{{ request.path }}" />
</head>
```


Optional: Add additional SEO meta tags:
```html
    <!-- SEO Meta Tags -->
    <meta name="description" content="Register your Telegram channel for cryptocurrency-based subscriptions with PayGatePrime.">
    <meta name="keywords" content="telegram, channel, subscription, cryptocurrency, payment">
    <meta name="author" content="PayGatePrime">
    <meta name="robots" content="index, follow">

    <!-- Open Graph (for social media sharing) -->
    <meta property="og:title" content="PayGatePrime - Telegram Channel Registration">
    <meta property="og:description" content="Monetize your Telegram channel with cryptocurrency subscriptions">
    <meta property="og:url" content="https://www.paygateprime.com">
    <meta property="og:type" content="website">

    <!-- Canonical URL for SEO -->
    <link rel="canonical" href="https://www.paygateprime.com{{ request.path }}" />
```


Testing:
1. Deploy the updated code
2. Visit https://www.paygateprime.com
3. View page source (Ctrl+U)
4. Verify presence of:
   <link rel="canonical" href="https://www.paygateprime.com/" />
5. Test on different pages:
   - / ‚Üí canonical: https://www.paygateprime.com/
   - /success ‚Üí canonical: https://www.paygateprime.com/success
6. Validate with Google Search Console


================================================================================
ENHANCEMENT 5: RATE LIMITING WITH REDIS (PRODUCTION)
================================================================================

Purpose: Enable production-grade rate limiting that persists across restarts
Benefits:
- Prevents abuse and spam
- Persists rate limit data across Cloud Run container restarts
- Scalable across multiple instances

Status: Currently disabled in code (lines 35-47)

Prerequisites:
1. Set up Redis instance (Google Cloud Memorystore or external Redis)
2. Get Redis connection URL

Location: Lines 35-47 in tpr10-26.py

Current code (commented out):
--------------------------------------------------------------------------------

# Initialize rate limiter (5 registrations per hour per IP)
# limiter = Limiter(
#     app=app,
#     key_func=get_remote_address,
#     default_limits=["200 per day", "50 per hour"],
#     storage_uri="memory://"
# )
# print("üîí [APP] Rate limiter initialized")


Updated code for production with Redis:
--------------------------------------------------------------------------------

# ============================================================================
# RATE LIMITING (Production with Redis)
# ============================================================================

from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

# Redis connection (fetch from Secret Manager or environment variable)
REDIS_URL = os.getenv('REDIS_URL', 'redis://your-redis-host:6379/0')

# Initialize rate limiter with Redis storage
limiter = Limiter(
    app=app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"],
    storage_uri=REDIS_URL,  # Use Redis for persistent storage
    strategy="fixed-window"  # Rate limit strategy
)

# Specific rate limit for registration endpoint
@app.route('/', methods=['GET', 'POST'])
@limiter.limit("5 per hour")  # 5 registrations per hour per IP
def register():
    # ... rest of the function

print(f"üîí [APP] Rate limiter initialized with Redis: {REDIS_URL}")


Rate limit configuration options:
--------------------------------------------------------------------------------

Strict (recommended for production):
    default_limits=["100 per day", "20 per hour"]
    @limiter.limit("3 per hour")  # For registration

Moderate:
    default_limits=["200 per day", "50 per hour"]
    @limiter.limit("5 per hour")  # For registration

Relaxed (for testing):
    default_limits=["500 per day", "100 per hour"]
    @limiter.limit("10 per hour")  # For registration


Error handler for rate limit exceeded:
--------------------------------------------------------------------------------

@app.errorhandler(429)
def ratelimit_handler(e):
    """
    Handle rate limit exceeded errors.
    Displays friendly error message to user.
    """
    print(f"‚ö†Ô∏è  [RATE_LIMIT] Rate limit exceeded: {get_remote_address()}")
    print(f"üïí [RATE_LIMIT] Time: {datetime.now().isoformat()}")
    flash('‚ö†Ô∏è  Too many registration attempts. Please try again in 1 hour.', 'warning')
    return render_template('error.html',
                         error="Rate limit exceeded. Please try again later."), 429


Testing:
1. Deploy with Redis configuration
2. Make multiple registration attempts quickly
3. Verify rate limit triggers after configured threshold
4. Verify error message displays correctly
5. Wait for timeout period and verify limit resets


Setting up Redis (Google Cloud Memorystore):
--------------------------------------------------------------------------------

1. Create Redis instance:
   gcloud redis instances create gcregister-redis \
     --size=1 \
     --region=us-central1 \
     --redis-version=redis_6_x

2. Get Redis host:
   gcloud redis instances describe gcregister-redis --region=us-central1

3. Store in Secret Manager:
   echo "redis://REDIS_HOST:6379/0" | gcloud secrets create REDIS_URL --data-file=-

4. Grant Cloud Run access:
   gcloud secrets add-iam-policy-binding REDIS_URL \
     --member=serviceAccount:YOUR-SERVICE-ACCOUNT@PROJECT.iam.gserviceaccount.com \
     --role=roles/secretmanager.secretAccessor

5. Update Cloud Run service to include REDIS_URL environment variable


================================================================================
ENHANCEMENT 6: ENVIRONMENT-BASED CONFIGURATION
================================================================================

Purpose: Different settings for development vs production
Benefits:
- Easier testing in development
- Stricter security in production
- Environment-specific logging

Location: After app initialization (around line 20)

Code to add:
--------------------------------------------------------------------------------

# ============================================================================
# ENVIRONMENT CONFIGURATION
# ============================================================================

import os

# Detect environment
ENV = os.getenv('ENV', 'production').lower()
DEBUG = ENV == 'development'

# Configure based on environment
if ENV == 'production':
    print("üè≠ [APP] Running in PRODUCTION mode")
    app.config['DEBUG'] = False
    app.config['TESTING'] = False
    app.config['SESSION_COOKIE_SECURE'] = True
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'

elif ENV == 'development':
    print("üîß [APP] Running in DEVELOPMENT mode")
    app.config['DEBUG'] = True
    app.config['TESTING'] = False
    app.config['SESSION_COOKIE_SECURE'] = False  # Allow HTTP for local testing

else:
    print(f"‚ö†Ô∏è  [APP] Unknown environment: {ENV}, defaulting to production")
    ENV = 'production'
    app.config['DEBUG'] = False


Usage:
1. Set ENV environment variable in Cloud Run:
   gcloud run services update gcregister10-26 \
     --set-env-vars="ENV=production" \
     --region=us-central1

2. For local development, set ENV=development


================================================================================
DEPLOYMENT INSTRUCTIONS
================================================================================

After implementing any of these enhancements:

1. Test locally (if possible):
   python tpr10-26.py
   Visit: http://localhost:8080

2. Deploy to Cloud Run:
   cd /OCTOBER/10-26/GCRegister10-26
   gcloud run deploy gcregister10-26 \
     --source . \
     --region us-central1 \
     --allow-unauthenticated

3. Verify deployment:
   Visit: https://www.paygateprime.com
   Test all functionality

4. Monitor logs:
   gcloud logging read "resource.type=cloud_run_revision AND
     resource.labels.service_name=gcregister10-26" \
     --limit 50

5. Check for errors:
   Look for lines with "‚ùå" or "ERROR" in logs


================================================================================
COMPLETE ENHANCED CODE EXAMPLE
================================================================================

Here's what the top of tpr10-26.py should look like with ALL enhancements:

```python
#!/usr/bin/env python
"""
GCRegister10-26: Channel Registration Service
Flask web application for registering Telegram channels into the payment system.
Enhanced for production use with custom domain www.paygateprime.com
"""
import os
from flask import Flask, render_template, redirect, url_for, flash, session, request, abort
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
import random
from config_manager import ConfigManager
from database_manager import DatabaseManager
from forms import ChannelRegistrationForm

# Initialize Flask app
app = Flask(__name__)

# Detect environment
ENV = os.getenv('ENV', 'production').lower()
DEBUG = ENV == 'development'

# Initialize configuration
print("üöÄ [APP] Initializing GCRegister10-26 Channel Registration Service")
print(f"üåç [APP] Environment: {ENV.upper()}")
config_manager = ConfigManager()
config = config_manager.initialize_config()

# Configure Flask app
app.config['SECRET_KEY'] = config['secret_key']
app.config['WTF_CSRF_ENABLED'] = True

# SESSION COOKIE SECURITY (Production)
if ENV == 'production':
    app.config['SESSION_COOKIE_SECURE'] = True
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_DOMAIN'] = '.paygateprime.com'
    app.config['PERMANENT_SESSION_LIFETIME'] = 3600
    print("üîí [APP] Session cookie security configured for production")

# Initialize database manager
try:
    db_manager = DatabaseManager(config)
    print("‚úÖ [APP] Database manager initialized successfully")
except Exception as e:
    print(f"‚ùå [APP] Failed to initialize database manager: {e}")
    db_manager = None

# SECURITY HEADERS MIDDLEWARE
@app.after_request
def add_security_headers(response):
    """Add security headers to all HTTP responses."""
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'DENY'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
    response.headers['Referrer-Policy'] = 'strict-origin-when-cross-origin'
    response.headers['Permissions-Policy'] = 'geolocation=(), microphone=(), camera=()'
    return response

print("‚úÖ [APP] Security headers middleware configured")

# HOST VALIDATION MIDDLEWARE
ALLOWED_HOSTS = [
    'www.paygateprime.com',
    'paygateprime.com',
    'gcregister10-26-291176869049.us-central1.run.app',
    'localhost',
    '127.0.0.1'
]

@app.before_request
def validate_host():
    """Validate the request hostname against allowed hosts."""
    if request.path == '/health':
        return None

    request_host = request.host.split(':')[0]

    if request_host not in ALLOWED_HOSTS:
        print(f"‚ö†Ô∏è  [SECURITY] Blocked request from invalid host: {request_host}")
        abort(403, "Access denied: Invalid host")

    return None

print(f"‚úÖ [APP] Host validation configured for: {', '.join(ALLOWED_HOSTS)}")

# RATE LIMITING (Optional - requires Redis in production)
# REDIS_URL = os.getenv('REDIS_URL', 'memory://')
# limiter = Limiter(
#     app=app,
#     key_func=get_remote_address,
#     default_limits=["200 per day", "50 per hour"],
#     storage_uri=REDIS_URL
# )
# print(f"üîí [APP] Rate limiter initialized")

# ... rest of the code (CAPTCHA function, routes, etc.) ...
```


================================================================================
TESTING CHECKLIST
================================================================================

After implementing enhancements:

Functionality Tests:
‚ñ° Registration form loads
‚ñ° CAPTCHA generates
‚ñ° Form validation works
‚ñ° Form submission succeeds
‚ñ° Success page displays
‚ñ° Database writes successful
‚ñ° API endpoints work

Security Tests:
‚ñ° HTTPS enforced (HTTP redirects)
‚ñ° Session cookies have Secure flag
‚ñ° Session cookies have HttpOnly flag
‚ñ° Session cookies have SameSite=Lax
‚ñ° Security headers present in all responses
‚ñ° Host validation blocks invalid hosts
‚ñ° Rate limiting triggers correctly (if enabled)

Browser Tests:
‚ñ° Chrome/Edge
‚ñ° Firefox
‚ñ° Safari
‚ñ° Mobile browsers

Online Security Scanners:
‚ñ° https://securityheaders.com/?q=www.paygateprime.com
‚ñ° https://www.ssllabs.com/ssltest/analyze.html?d=www.paygateprime.com
‚ñ° https://observatory.mozilla.org/analyze/www.paygateprime.com


================================================================================
ROLLBACK PROCEDURE
================================================================================

If any enhancement causes issues:

1. Identify the problematic enhancement from logs
2. Comment out or remove the specific enhancement
3. Redeploy:
   gcloud run deploy gcregister10-26 --source . --region us-central1
4. Verify service works without enhancement
5. Review and fix enhancement code
6. Re-deploy with corrected code


================================================================================
MAINTENANCE NOTES
================================================================================

Regular Maintenance Tasks:

Monthly:
- Review security headers best practices (standards evolve)
- Check for Flask security updates
- Review rate limit thresholds based on usage
- Test all security features

Quarterly:
- Security audit with online scanners
- Review and update ALLOWED_HOSTS if needed
- Review session timeout settings
- Test rollback procedures

Annually:
- Full security review
- Update dependencies
- Review and update security policies


================================================================================
SUMMARY
================================================================================

Enhancements Available:
1. ‚úÖ Session Cookie Security - RECOMMENDED
2. ‚úÖ Security Headers - RECOMMENDED
3. ‚úÖ Host Validation - RECOMMENDED
4. ‚úÖ Canonical URL - RECOMMENDED for SEO
5. ‚ö†Ô∏è  Rate Limiting - Requires Redis setup
6. ‚ö†Ô∏è  Environment Config - Optional but useful

Implementation Order:
1. Start with Session Cookie Security (easiest, no dependencies)
2. Add Security Headers (easy, high impact)
3. Add Host Validation (easy, good security)
4. Add Canonical URL (easy, good for SEO)
5. Consider Rate Limiting later (requires Redis)

Remember: Your application works fine without these enhancements!
These are production best practices for enhanced security and SEO.


================================================================================
QUESTIONS OR ISSUES?
================================================================================

If you encounter any issues while implementing these enhancements:

1. Check Cloud Run logs for errors
2. Test each enhancement individually
3. Verify environment variables are set
4. Review Flask documentation
5. Use browser DevTools to inspect headers and cookies

Most issues are caused by:
- Typos in configuration values
- Missing environment variables
- Incorrect indentation in Python code
- Browser cache (test in incognito mode)


================================================================================
END OF SECURITY ENHANCEMENTS GUIDE
================================================================================

Good luck with your production deployment! üõ°Ô∏è
