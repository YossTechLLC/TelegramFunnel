================================================================================
GCSPLIT ‚Üí GCHOSTPAY WEBHOOK TOKEN FLOW
Time-Sensitive Token Generation and Verification
TelegramFunnel Payment System - October 2025
================================================================================

This document explains in detail how the GCSplit10-21 service builds and sends
cryptographically signed tokens to the GCHostPay10-21 service, with special
emphasis on the TIME-SENSITIVE nature of token validation and the security
mechanisms in place.

================================================================================
TABLE OF CONTENTS
================================================================================

1. Overview
2. Why Time Sensitivity Matters
3. Token Structure (Binary Format)
4. Token Generation Process (GCSplit10-21)
5. Token Transmission Process
6. Token Decoding Process (GCHostPay10-21)
7. Time Window Validation (CRITICAL)
8. Security Mechanisms
9. Failure Scenarios
10. Code References
11. Timing Diagrams
12. Best Practices

================================================================================
1. OVERVIEW
================================================================================

The GCSplit ‚Üí GCHostPay webhook communication uses TIME-LIMITED cryptographic
tokens to securely transmit transaction details for automated ETH payments.

Key Characteristics:
- ‚è∞ TIME-LIMITED: Token expires 60 seconds after creation
- üîê SIGNED: HMAC-SHA256 signature prevents tampering
- üì¶ COMPACT: Binary packed format for efficiency
- üîÑ ONE-TIME: Each token is unique and tied to a specific transaction
- ‚ö° IMMEDIATE: Designed for near-instant processing

Token Validity Window: **60 seconds** (with 5-second grace period)

Purpose:
- Trigger automated ETH payment from host wallet to ChangeNow
- Ensure payment instructions cannot be replayed or modified
- Link ETH payment to specific ChangeNow transaction ID
- Maintain audit trail through unique_id across database tables

================================================================================
2. WHY TIME SENSITIVITY MATTERS
================================================================================

SECURITY RATIONALE
------------------

The 60-second expiration window serves multiple critical security purposes:

1. **Replay Attack Prevention**
   - Stolen tokens cannot be reused after expiration
   - Limits window of opportunity for attackers
   - Each ChangeNow transaction gets a fresh token

2. **Transaction State Synchronization**
   - ChangeNow transactions have short-lived "waiting" status
   - Token expiration aligns with ChangeNow's expected payment window
   - Prevents payments to expired/cancelled ChangeNow transactions

3. **Database Integrity**
   - Short window reduces chance of duplicate payments
   - Ensures unique_id hasn't been processed already
   - Links correct ETH payment to correct ChangeNow transaction

4. **Operational Efficiency**
   - Forces immediate processing (no queuing old requests)
   - Reduces server resource allocation for old tokens
   - Simplifies error handling (expired = rejected)


TIMING CONSTRAINTS
------------------

The 60-second window is carefully chosen based on:

‚úÖ ChangeNow API Response Time: < 5 seconds
‚úÖ GCSplit Processing Time: < 5 seconds
‚úÖ Network Latency (GCSplit ‚Üí GCHostPay): < 1 second
‚úÖ GCHostPay Token Validation: < 1 second
‚úÖ ChangeNow Status Check: < 3 seconds
‚úÖ ETH Transaction Broadcasting: < 5 seconds
‚úÖ Total Expected Time: ~20 seconds

Buffer Time: 40 seconds (for network issues, retries, delays)

Grace Period: 5 seconds (for clock skew between servers)


REAL-WORLD TIMING
-----------------

Typical workflow timing:

00:00 - GCSplit creates ChangeNow transaction
00:02 - ChangeNow API responds with transaction ID
00:03 - GCSplit generates HostPay token (timestamp embedded)
00:04 - GCSplit sends webhook to GCHostPay
00:05 - GCHostPay receives webhook request
00:06 - GCHostPay validates token (checks timestamp: 3 seconds old ‚úÖ)
00:07 - GCHostPay checks ChangeNow status (waiting ‚úÖ)
00:09 - GCHostPay broadcasts ETH transaction
00:15 - ETH transaction confirmed on blockchain

Total Time from Token Creation to ETH Broadcast: ~6 seconds
Token Age at Validation: ~3 seconds (well within 60-second window)


FAILURE SCENARIOS (Time-Related)
---------------------------------

Scenario 1: Network Delay (45 seconds)
- Token created at T+0
- Network congestion delays webhook delivery
- Token arrives at GCHostPay at T+45
- Token age: 45 seconds ‚úÖ VALID (within 60-second window)
- Processing continues normally

Scenario 2: Service Outage (70 seconds)
- Token created at T+0
- GCHostPay service down for maintenance
- Request retried at T+70
- Token age: 70 seconds ‚ùå EXPIRED (exceeds 60-second window)
- Request rejected with "Token expired" error
- GCSplit must create new ChangeNow transaction + new token

Scenario 3: Clock Skew (10 seconds)
- GCSplit server clock: 10:00:00
- GCHostPay server clock: 10:00:10 (10 seconds ahead)
- Token created at 10:00:00 (GCSplit time)
- Token arrives at 10:00:02 (GCSplit time)
- GCHostPay validates at 10:00:12 (GCHostPay time)
- Apparent token age: 12 seconds (due to clock skew)
- Grace period: 5 seconds allows for clock differences
- Validation: ‚úÖ PASSES (12 seconds within acceptable range)


================================================================================
3. TOKEN STRUCTURE (BINARY FORMAT)
================================================================================

The token is a BINARY-PACKED data structure, NOT JSON or plain text.

Binary Structure (byte-by-byte):
---------------------------------

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FIELD                ‚îÇ SIZE         ‚îÇ FORMAT        ‚îÇ DESCRIPTION    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ unique_id            ‚îÇ 16 bytes     ‚îÇ UTF-8 fixed   ‚îÇ Database ID    ‚îÇ
‚îÇ cn_api_id_length     ‚îÇ 1 byte       ‚îÇ uint8         ‚îÇ Length prefix  ‚îÇ
‚îÇ cn_api_id            ‚îÇ N bytes      ‚îÇ UTF-8 var     ‚îÇ ChangeNow ID   ‚îÇ
‚îÇ from_currency_length ‚îÇ 1 byte       ‚îÇ uint8         ‚îÇ Length prefix  ‚îÇ
‚îÇ from_currency        ‚îÇ M bytes      ‚îÇ UTF-8 var     ‚îÇ "eth"          ‚îÇ
‚îÇ from_network_length  ‚îÇ 1 byte       ‚îÇ uint8         ‚îÇ Length prefix  ‚îÇ
‚îÇ from_network         ‚îÇ P bytes      ‚îÇ UTF-8 var     ‚îÇ "eth"          ‚îÇ
‚îÇ from_amount          ‚îÇ 8 bytes      ‚îÇ double (>d)   ‚îÇ ETH amount     ‚îÇ
‚îÇ payin_address_length ‚îÇ 1 byte       ‚îÇ uint8         ‚îÇ Length prefix  ‚îÇ
‚îÇ payin_address        ‚îÇ Q bytes      ‚îÇ UTF-8 var     ‚îÇ ETH address    ‚îÇ
‚îÇ timestamp            ‚îÇ 4 bytes      ‚îÇ uint32 (>I)   ‚îÇ Unix timestamp ‚îÇ
‚îÇ signature            ‚îÇ 16 bytes     ‚îÇ HMAC truncat. ‚îÇ HMAC-SHA256    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Minimum Size: 52 bytes
Maximum Size: ~350 bytes (depends on variable field lengths)
Typical Size: ~120 bytes


FIELD DETAILS
-------------

1. unique_id (16 bytes, fixed):
   - Database linking ID
   - Generated by GCSplit when inserting to split_payout_request
   - Format: Alphanumeric string (e.g., "AH7CWKX82NCPIII9")
   - Padded with null bytes (\x00) if shorter than 16 chars
   - Purpose: Links split_payout_request, split_payout_que, split_payout_hostpay

2. cn_api_id (variable length):
   - ChangeNow transaction ID
   - Format: Alphanumeric (e.g., "ec4b26e3a392e6")
   - Length: 14-16 characters (typically 14)
   - Purpose: Identify ChangeNow transaction for status checks

3. from_currency (variable length):
   - Source cryptocurrency (lowercase)
   - Format: "eth", "btc", "usdt", etc.
   - Length: 3-4 characters
   - Purpose: Specify which cryptocurrency to send

4. from_network (variable length):
   - Blockchain network (lowercase)
   - Format: "eth", "bsc", "polygon", etc.
   - Length: 3-7 characters
   - Purpose: Specify which network to use

5. from_amount (8 bytes, double precision):
   - Amount of ETH to send
   - Format: IEEE 754 double (big-endian)
   - Range: 0.000001 to 1000000.0 ETH
   - Precision: ~15 decimal digits
   - Purpose: Exact amount for wallet manager to send

6. payin_address (variable length):
   - ChangeNow deposit address
   - Format: Ethereum address (0x + 40 hex chars = 42 chars)
   - Example: "0x1D70FD91E955445A2AA09D43a520312b71A6Bf01"
   - Purpose: Destination for ETH payment

7. timestamp (4 bytes, uint32):
   - Unix timestamp (seconds since epoch)
   - Range: 0 to 4,294,967,295 (year 2106)
   - Purpose: ‚è∞ TIME VALIDATION (CRITICAL)
   - Validation: current_time - 60 <= timestamp <= current_time + 5

8. signature (16 bytes, truncated HMAC):
   - HMAC-SHA256 of all preceding data
   - Truncated to first 16 bytes (128 bits)
   - Full signature: 32 bytes, truncated for compactness
   - Security: 128 bits = 3.4√ó10¬≥‚Å∏ possible signatures (unbreakable)
   - Purpose: Verify data integrity and authenticity


WHY BINARY FORMAT?
------------------

Advantages over JSON:
‚úÖ Smaller size (~120 bytes vs ~300 bytes JSON)
‚úÖ Faster parsing (no JSON deserialization)
‚úÖ Fixed-size fields for critical data (timestamp, amount)
‚úÖ No encoding ambiguity (UTF-8 vs ASCII vs Unicode)
‚úÖ Signature covers exact bytes (no whitespace variations)

Disadvantages:
‚ùå Not human-readable
‚ùå Requires careful parsing (offset tracking)
‚ùå Version changes require careful migration
‚ùå Debugging more difficult (must decode manually)

Decision: Security and performance trump readability


EXAMPLE TOKEN (DECODED)
------------------------

Input Data:
- unique_id: "AH7CWKX82NCPIII9"
- cn_api_id: "ec4b26e3a392e6"
- from_currency: "eth"
- from_network: "eth"
- from_amount: 0.0005574
- payin_address: "0x1D70FD91E955445A2AA09D43a520312b71A6Bf01"
- timestamp: 1730841645
- signing_key: "your-secret-signing-key-here"

Binary Packed (hexadecimal):
41 48 37 43 57 4B 58 38 32 4E 43 50 49 49 49 39  ‚Üê unique_id (16 bytes)
0E                                                ‚Üê cn_api_id length (14)
65 63 34 62 32 36 65 33 61 33 39 32 65 36        ‚Üê cn_api_id (14 bytes)
03                                                ‚Üê currency length (3)
65 74 68                                          ‚Üê "eth" (3 bytes)
03                                                ‚Üê network length (3)
65 74 68                                          ‚Üê "eth" (3 bytes)
3F 42 54 C8 5E F7 A2 9A                          ‚Üê amount (8-byte double)
2A                                                ‚Üê address length (42)
30 78 31 44 37 30 46 44 39 31 45 39 35 35 34 34  ‚Üê address part 1
35 41 32 41 41 30 39 44 34 33 61 35 32 30 33 31  ‚Üê address part 2
32 62 37 31 41 36 42 66 30 31                    ‚Üê address part 3
67 1A 8C 0D                                      ‚Üê timestamp (4 bytes)
[16 bytes of HMAC signature]                     ‚Üê signature

Total Size: 110 bytes

Base64 Encoded Token:
QUg3Q1dLWDgyTkNQSUlJOQ5lYzRiMjZlM2EzOTJlNgNldGgDZXRoP0JUyF73oppv
MHgxRDcwRkQ5MUU5NTU0NDRBNEFBMDK0M2E1MjAzMTJiNzFBNkJmMDFnGowN
[signature bytes]


================================================================================
4. TOKEN GENERATION PROCESS (GCSPLIT10-21)
================================================================================

FUNCTION: build_hostpay_token()
LOCATION: GCSplit10-21/tps10-21.py:142-235
CALLED BY: trigger_hostpay_webhook() [Line 267]
CALLED WHEN: After ChangeNow transaction created successfully


STEP-BY-STEP TOKEN GENERATION
------------------------------

Step 1: Prepare unique_id (Fixed 16 bytes)
```python
unique_id_bytes = unique_id.encode('utf-8')[:16].ljust(16, b'\x00')
```
- Encode string to UTF-8 bytes
- Truncate to 16 bytes if longer
- Pad with null bytes (\x00) if shorter
- Result: Exactly 16 bytes

Example:
Input:  "AH7CWKX82NCPIII9" (16 chars)
Output: b'AH7CWKX82NCPIII9' (16 bytes)

Input:  "ABC123" (6 chars)
Output: b'ABC123\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' (16 bytes)


Step 2: Encode Variable-Length Fields
```python
cn_api_id_bytes = cn_api_id.encode('utf-8')
from_currency_bytes = from_currency.lower().encode('utf-8')
from_network_bytes = from_network.lower().encode('utf-8')
payin_address_bytes = payin_address.encode('utf-8')
```
- Convert strings to UTF-8 bytes
- Lowercase currency and network for consistency
- No padding (variable length)


Step 3: Get Current Timestamp ‚è∞ (CRITICAL)
```python
current_timestamp = int(time.time())
```
- Unix timestamp (seconds since January 1, 1970)
- Example: 1730841645 (November 5, 2024, 22:34:05 UTC)
- ‚ö†Ô∏è This is the CREATION TIME that will be validated later
- Stored as 4-byte unsigned integer (uint32)


Step 4: Build Packed Data Structure
```python
packed_data = bytearray()

# Fixed 16-byte unique_id
packed_data.extend(unique_id_bytes)

# Variable length fields with 1-byte length prefix
packed_data.append(len(cn_api_id_bytes))
packed_data.extend(cn_api_id_bytes)

packed_data.append(len(from_currency_bytes))
packed_data.extend(from_currency_bytes)

packed_data.append(len(from_network_bytes))
packed_data.extend(from_network_bytes)

# 8-byte double for amount
packed_data.extend(struct.pack(">d", from_amount))

# Payin address
packed_data.append(len(payin_address_bytes))
packed_data.extend(payin_address_bytes)

# 4-byte timestamp
packed_data.extend(struct.pack(">I", current_timestamp))
```

Key Points:
- ">d" = big-endian double (8 bytes)
- ">I" = big-endian unsigned int (4 bytes)
- Length prefixes allow variable-length fields
- No delimiters needed (length-prefixed parsing)


Step 5: Generate HMAC-SHA256 Signature
```python
full_signature = hmac.new(signing_key.encode(), bytes(packed_data), hashlib.sha256).digest()
truncated_signature = full_signature[:16]
```

Process:
1. Convert signing_key to bytes
2. Hash packed_data with HMAC-SHA256
3. Result: 32-byte signature
4. Truncate to first 16 bytes (128 bits)

Why Truncate?
- 128 bits = sufficient security (2^128 = 3.4√ó10¬≥‚Å∏ combinations)
- Reduces token size by 16 bytes
- Still computationally infeasible to forge


Step 6: Combine Data + Signature
```python
final_data = bytes(packed_data) + truncated_signature
```

Structure:
[unique_id][cn_api_id_len][cn_api_id][currency_len][currency]...
...[network_len][network][amount][address_len][address][timestamp][signature]


Step 7: Base64 URL-Safe Encoding
```python
token = base64.urlsafe_b64encode(final_data).rstrip(b'=').decode('utf-8')
```

Process:
1. Base64 encode binary data (URL-safe variant)
2. Strip trailing '=' padding
3. Convert bytes to string

Why URL-Safe?
- Uses - and _ instead of + and /
- Can be safely transmitted in URLs or JSON
- No encoding issues with HTTP headers

Result: Alphanumeric string ready for transmission


LOGGING AND VERIFICATION
-------------------------

The function logs all parameters for debugging:

```
üîê [HOSTPAY_TOKEN] Building HostPay webhook token
‚úÖ [HOSTPAY_TOKEN] Token generated successfully
üÜî [HOSTPAY_TOKEN] Unique ID: AH7CWKX82NCPIII9
üÜî [HOSTPAY_TOKEN] CN API ID: ec4b26e3a392e6
üí∞ [HOSTPAY_TOKEN] Amount: 0.0005574 ETH
üåê [HOSTPAY_TOKEN] Network: eth
üè¶ [HOSTPAY_TOKEN] Payin Address: 0x1D70FD91E955445A2AA09D43a520312b71A6Bf01
‚è∞ [HOSTPAY_TOKEN] Timestamp: 1730841645
üîê [HOSTPAY_TOKEN] Token size: 187 chars
```


ERROR HANDLING
--------------

The function returns None if any step fails:

```python
except Exception as e:
    print(f"‚ùå [HOSTPAY_TOKEN] Error building token: {e}")
    return None
```

Possible Failures:
- UTF-8 encoding error (invalid characters)
- struct.pack error (invalid amount value)
- HMAC generation error (invalid signing key)
- Base64 encoding error (corrupted data)


================================================================================
5. TOKEN TRANSMISSION PROCESS
================================================================================

FUNCTION: trigger_hostpay_webhook()
LOCATION: GCSplit10-21/tps10-21.py:237-317
CALLED BY: create_fixed_rate_transaction() [Line 428]
CALLED WHEN: After ChangeNow transaction saved to split_payout_que


TRANSMISSION WORKFLOW
---------------------

Step 1: Get Configuration
```python
hostpay_webhook_url = config.get('hostpay_webhook_url')
signing_key = config.get('tps_hostpay_signing_key')
```

Configuration Sources (Google Secret Manager):
- HOSTPAY_WEBHOOK_URL: "https://tphp10-21-xxx.run.app"
- TPS_HOSTPAY_SIGNING_KEY: Shared HMAC key

Validation:
- If webhook URL not configured ‚Üí Return False (skip payment)
- If signing key not available ‚Üí Return False (cannot create token)


Step 2: Build Token (Call build_hostpay_token)
```python
token = build_hostpay_token(
    unique_id=unique_id,
    cn_api_id=cn_api_id,
    from_currency=from_currency,
    from_network=from_network,
    from_amount=from_amount,
    payin_address=payin_address,
    signing_key=signing_key
)
```

If token is None ‚Üí Return False


Step 3: Prepare HTTP Request Payload
```python
payload = {
    "token": token
}
```

Format: JSON
Content-Type: application/json

Example:
```json
{
  "token": "QUg3Q1dLWDgyTkNQSUlJOQ5lYzRiMjZlM2EzOTJlNgNldGgDZXRoP0JUyF73oppv..."
}
```


Step 4: Send POST Request
```python
response = requests.post(
    hostpay_webhook_url,
    json=payload,
    headers={'Content-Type': 'application/json'},
    timeout=30
)
```

Request Details:
- Method: POST
- URL: https://tphp10-21-xxx.run.app
- Headers: Content-Type: application/json
- Body: JSON payload with token
- Timeout: 30 seconds

‚è∞ TIMING: This HTTP request is where the time-sensitive token travels
          from GCSplit (token created) to GCHostPay (token validated).
          The timestamp embedded in the token starts aging NOW.


Step 5: Check Response Status
```python
if response.status_code == 200:
    print(f"‚úÖ [HOSTPAY_WEBHOOK] Webhook triggered successfully")
    try:
        response_data = response.json()
        print(f"üì¶ [HOSTPAY_WEBHOOK] Response: {response_data}")
    except:
        pass
    return True
else:
    print(f"‚ùå [HOSTPAY_WEBHOOK] Webhook failed with status {response.status_code}: {response.text}")
    return False
```

Success Criteria:
- HTTP 200 OK
- Response body (optional, for logging)

Failure Conditions:
- HTTP 400: Bad Request (invalid token, expired token)
- HTTP 401: Unauthorized (signature mismatch)
- HTTP 500: Internal Server Error (GCHostPay processing error)


Step 6: Error Handling
```python
except requests.exceptions.Timeout:
    print(f"‚ùå [HOSTPAY_WEBHOOK] Request timeout")
    return False
except requests.exceptions.ConnectionError:
    print(f"‚ùå [HOSTPAY_WEBHOOK] Connection error")
    return False
except Exception as e:
    print(f"‚ùå [HOSTPAY_WEBHOOK] Error triggering webhook: {e}")
    return False
```

Error Types:
- Timeout: 30-second limit exceeded (network issue)
- ConnectionError: Cannot reach GCHostPay (service down)
- Other: Generic exceptions (DNS failure, SSL error, etc.)


LOGGING EXAMPLE
---------------

Successful Webhook:
```
üöÄ [HOSTPAY_WEBHOOK] Triggering GCHostPay10-21 webhook
üåê [HOSTPAY_WEBHOOK] URL: https://tphp10-21-291176869049.us-central1.run.app
‚úÖ [HOSTPAY_WEBHOOK] Webhook triggered successfully
üì¶ [HOSTPAY_WEBHOOK] Response: {
  "status": "success",
  "message": "ETH payment executed and logged successfully",
  "data": {
    "unique_id": "AH7CWKX82NCPIII9",
    "cn_api_id": "ec4b26e3a392e6",
    "tx_hash": "0x99a936f95ee27b32ecce738c9998b4b4d51879368d6582a7a761942fb15d1489",
    "gas_used": 21000,
    "block_number": 23632807
  }
}
```

Failed Webhook (Token Expired):
```
üöÄ [HOSTPAY_WEBHOOK] Triggering GCHostPay10-21 webhook
üåê [HOSTPAY_WEBHOOK] URL: https://tphp10-21-291176869049.us-central1.run.app
‚ùå [HOSTPAY_WEBHOOK] Webhook failed with status 400: Invalid token: Token expired (created 75 seconds ago, max 60 seconds)
```


TIMING CONSIDERATIONS
---------------------

Network Latency Budget:
- DNS Resolution: 10-50ms
- TCP Handshake: 20-100ms
- TLS Handshake: 50-200ms
- HTTP Request: 10-50ms
- GCHostPay Processing: 100-500ms
- HTTP Response: 10-50ms
Total: 200-950ms (typical: ~500ms)

‚ö†Ô∏è The 30-second timeout is generous and should never be hit under normal
   conditions. If timeout occurs, it indicates serious network or service issues.

‚è∞ Token Age at GCHostPay Receipt:
   - Ideal: 0-5 seconds (same datacenter)
   - Normal: 5-15 seconds (cross-region)
   - Acceptable: 15-45 seconds (network congestion)
   - Expired: > 60 seconds (rejected)


================================================================================
6. TOKEN DECODING PROCESS (GCHOSTPAY10-21)
================================================================================

FUNCTION: decode_and_verify_hostpay_token()
LOCATION: GCHostPay10-21/tphp10-21.py:143-270
CALLED BY: hostpay_webhook() [Line 305]
CALLED WHEN: Webhook request received from GCSplit10-21


DECODING WORKFLOW (STEP-BY-STEP)
---------------------------------

Step 1: Base64 URL-Safe Decoding
```python
padding = '=' * (-len(token) % 4)
try:
    raw = base64.urlsafe_b64decode(token + padding)
except Exception:
    raise ValueError("Invalid token: cannot decode base64")
```

Process:
- Add padding if needed (base64 requires length multiple of 4)
- Decode from URL-safe base64 to raw bytes
- Catch any decoding errors (invalid characters, corrupted data)

Example:
Input:  "QUg3Q1dLWDgyTkNQSUlJOQ5lYzRiMjZlM2EzOTJlNg..."
Output: b'AH7CWKX82NCPIII9\x0eec4b26e3a392e6\x03eth...'


Step 2: Size Validation
```python
if len(raw) < 52:
    raise ValueError(f"Invalid token: too small (got {len(raw)}, minimum 52)")
```

Minimum Token Size Calculation:
- 16 bytes: unique_id (fixed)
- 1+1 bytes: cn_api_id (min 1 char)
- 1+1 bytes: from_currency (min 1 char)
- 1+1 bytes: from_network (min 1 char)
- 8 bytes: from_amount (fixed)
- 1+1 bytes: payin_address (min 1 char)
- 4 bytes: timestamp (fixed)
- 16 bytes: signature (fixed)
= 52 bytes minimum

Purpose: Prevent buffer underflow attacks


Step 3: Parse Fixed 16-Byte unique_id
```python
offset = 0
unique_id_bytes = raw[offset:offset+16]
unique_id = unique_id_bytes.rstrip(b'\x00').decode('utf-8')
offset += 16
```

Process:
- Extract first 16 bytes
- Strip null byte padding from right
- Decode UTF-8 to string
- Move offset forward by 16

Example:
Input:  b'AH7CWKX82NCPIII9'
Output: "AH7CWKX82NCPIII9"
Offset: 0 ‚Üí 16


Step 4: Parse Variable-Length cn_api_id
```python
if offset + 1 > len(raw):
    raise ValueError("Invalid token: missing cn_api_id length field")
cn_api_id_len = raw[offset]
offset += 1

if offset + cn_api_id_len > len(raw):
    raise ValueError("Invalid token: incomplete cn_api_id")
cn_api_id = raw[offset:offset+cn_api_id_len].decode('utf-8')
offset += cn_api_id_len
```

Process:
- Read 1-byte length prefix
- Validate enough bytes remaining
- Extract N bytes based on length
- Decode UTF-8 to string
- Move offset forward

Example:
Input:  b'\x0eec4b26e3a392e6'
Length: 14 (0x0e)
Output: "ec4b26e3a392e6"
Offset: 16 ‚Üí 17 ‚Üí 31


Step 5: Parse from_currency (Same Pattern)
```python
if offset + 1 > len(raw):
    raise ValueError("Invalid token: missing from_currency length field")
from_currency_len = raw[offset]
offset += 1

if offset + from_currency_len > len(raw):
    raise ValueError("Invalid token: incomplete from_currency")
from_currency = raw[offset:offset+from_currency_len].decode('utf-8')
offset += from_currency_len
```

Example:
Input:  b'\x03eth'
Length: 3
Output: "eth"
Offset: 31 ‚Üí 32 ‚Üí 35


Step 6: Parse from_network (Same Pattern)
```python
if offset + 1 > len(raw):
    raise ValueError("Invalid token: missing from_network length field")
from_network_len = raw[offset]
offset += 1

if offset + from_network_len > len(raw):
    raise ValueError("Invalid token: incomplete from_network")
from_network = raw[offset:offset+from_network_len].decode('utf-8')
offset += from_network_len
```

Example:
Input:  b'\x03eth'
Length: 3
Output: "eth"
Offset: 35 ‚Üí 36 ‚Üí 39


Step 7: Parse 8-Byte from_amount
```python
if offset + 8 > len(raw):
    raise ValueError("Invalid token: incomplete from_amount")
from_amount = struct.unpack(">d", raw[offset:offset+8])[0]
offset += 8
```

Process:
- Extract 8 bytes
- Unpack as big-endian double (">d")
- Result is Python float

Example:
Input:  b'\x3f\x42\x54\xc8\x5e\xf7\xa2\x9a'
Output: 0.0005574
Offset: 39 ‚Üí 47


Step 8: Parse Variable-Length payin_address
```python
if offset + 1 > len(raw):
    raise ValueError("Invalid token: missing payin_address length field")
payin_address_len = raw[offset]
offset += 1

if offset + payin_address_len > len(raw):
    raise ValueError("Invalid token: incomplete payin_address")
payin_address = raw[offset:offset+payin_address_len].decode('utf-8')
offset += payin_address_len
```

Example:
Input:  b'\x2a0x1D70FD91E955445A2AA09D43a520312b71A6Bf01'
Length: 42 (0x2a)
Output: "0x1D70FD91E955445A2AA09D43a520312b71A6Bf01"
Offset: 47 ‚Üí 48 ‚Üí 90


Step 9: Parse 4-Byte Timestamp ‚è∞ (CRITICAL)
```python
if offset + 4 > len(raw):
    raise ValueError("Invalid token: incomplete timestamp")
timestamp = struct.unpack(">I", raw[offset:offset+4])[0]
offset += 4
```

Process:
- Extract 4 bytes
- Unpack as big-endian unsigned int (">I")
- Result is Unix timestamp (seconds since epoch)

Example:
Input:  b'\x67\x1a\x8c\x0d'
Output: 1730841645 (November 5, 2024, 22:34:05 UTC)
Offset: 90 ‚Üí 94

‚ö†Ô∏è This timestamp will be validated in Step 11


Step 10: Extract Signature
```python
if len(raw) - offset != 16:
    raise ValueError(f"Invalid token: wrong signature size (got {len(raw) - offset}, expected 16)")

data = raw[:offset]  # All data except signature
sig = raw[offset:]   # The signature
```

Process:
- Verify exactly 16 bytes remaining
- Split token into data + signature
- Data: Everything parsed so far
- Signature: Last 16 bytes

Example:
Offset: 94
Raw Length: 110 bytes
Signature: raw[94:110] (16 bytes)


Step 11: Verify HMAC Signature
```python
expected_full_sig = hmac.new(signing_key.encode(), data, hashlib.sha256).digest()
expected_sig = expected_full_sig[:16]
if not hmac.compare_digest(sig, expected_sig):
    raise ValueError("Signature mismatch - token may be tampered or invalid signing key")
```

Process:
1. Recreate HMAC using same signing_key and data
2. Hash data with HMAC-SHA256 (32-byte result)
3. Truncate to first 16 bytes (same as token generation)
4. Compare using constant-time comparison (prevents timing attacks)

Security:
- hmac.compare_digest() prevents timing side-channel attacks
- Any modification to data ‚Üí different signature
- Cannot forge signature without knowing signing_key

Failure Reasons:
‚ùå Token tampered with (data modified)
‚ùå Wrong signing_key (server misconfiguration)
‚ùå Token corrupted during transmission
‚ùå Different encoding/packing (version mismatch)


Step 12: Validate Timestamp ‚è∞ (CRITICAL - TIME SENSITIVITY)
```python
current_time = int(time.time())
if not (current_time - 60 <= timestamp <= current_time + 5):
    time_diff = current_time - timestamp
    raise ValueError(f"Token expired (created {abs(time_diff)} seconds ago, max 60 seconds)")
```

‚ö†Ô∏è THIS IS THE TIME-SENSITIVE VALIDATION THAT ENFORCES THE 60-SECOND WINDOW ‚ö†Ô∏è

Validation Logic:
- Get current server time
- Calculate valid range:
  - Minimum: current_time - 60 (token up to 60 seconds old)
  - Maximum: current_time + 5 (allow 5-second clock skew)
- Check if timestamp falls within range

Example (VALID):
- Token timestamp: 1730841645 (22:34:05 UTC)
- Current time:    1730841650 (22:34:10 UTC)
- Time difference: 5 seconds
- Validation: 1730841590 <= 1730841645 <= 1730841655 ‚úÖ VALID

Example (EXPIRED):
- Token timestamp: 1730841600 (22:33:20 UTC)
- Current time:    1730841675 (22:34:35 UTC)
- Time difference: 75 seconds
- Validation: 1730841615 <= 1730841600 <= 1730841680 ‚ùå EXPIRED

Example (FUTURE TOKEN - Clock Skew):
- Token timestamp: 1730841653 (22:34:13 UTC)
- Current time:    1730841650 (22:34:10 UTC)
- Time difference: -3 seconds (token from "future")
- Validation: 1730841590 <= 1730841653 <= 1730841655 ‚úÖ VALID
- Reason: 5-second grace period allows for clock differences


Step 13: Log Validation Success
```python
print(f"üîì [TOKEN_VALIDATION] Token validated successfully")
print(f"‚è∞ [TOKEN_VALIDATION] Token age: {current_time - timestamp} seconds")
```

Logging Example:
```
üîç [TOKEN_DEBUG] Raw data size: 110 bytes
üîç [TOKEN_DEBUG] Data size: 94 bytes
üîç [TOKEN_DEBUG] Signature size: 16 bytes
üîì [TOKEN_VALIDATION] Token validated successfully
‚è∞ [TOKEN_VALIDATION] Token age: 5 seconds
```


Step 14: Return Extracted Values
```python
return unique_id, cn_api_id, from_currency, from_network, from_amount, payin_address
```

Return Type: Tuple[str, str, str, str, float, str]

Example:
```python
(
    "AH7CWKX82NCPIII9",              # unique_id
    "ec4b26e3a392e6",                # cn_api_id
    "eth",                           # from_currency
    "eth",                           # from_network
    0.0005574,                       # from_amount
    "0x1D70FD91E955445A2AA09D43a520312b71A6Bf01"  # payin_address
)
```


================================================================================
7. TIME WINDOW VALIDATION (CRITICAL)
================================================================================

‚è∞ THE HEART OF TIME SENSITIVITY ‚è∞

This section explains in extreme detail the 60-second validation window
and why it's absolutely critical for security and operational correctness.


THE 60-SECOND WINDOW EXPLAINED
-------------------------------

Validation Formula:
```python
current_time - 60 <= timestamp <= current_time + 5
```

Breakdown:

Lower Bound: current_time - 60
- Tokens older than 60 seconds are REJECTED
- Purpose: Prevent replay attacks
- Reasoning: ChangeNow transactions expire if not paid quickly

Upper Bound: current_time + 5
- Tokens with timestamps up to 5 seconds in the future are ACCEPTED
- Purpose: Allow for clock skew between servers
- Reasoning: GCSplit and GCHostPay may have slightly different system clocks


TIME WINDOW VISUAL REPRESENTATION
----------------------------------

Timeline (current_time = 1000):

                     Valid Window (65 seconds)
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ                             ‚îÇ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Time
       |          |                             |          |
      935        940                          1000       1005
       |          |                             |          |
   Too Old   Oldest Valid                  Current    Future OK
   (expired)  (60s old)                     Time     (+5s grace)


Examples:

Token Age: -10 seconds (timestamp = 1010)
Status: ‚ùå REJECTED (too far in future)
Reason: Likely clock skew > 5 seconds or malicious token

Token Age: -3 seconds (timestamp = 1003)
Status: ‚úÖ ACCEPTED (within grace period)
Reason: Minor clock difference between servers

Token Age: 0 seconds (timestamp = 1000)
Status: ‚úÖ ACCEPTED (ideal case)
Reason: Instant processing

Token Age: 30 seconds (timestamp = 970)
Status: ‚úÖ ACCEPTED (normal processing delay)
Reason: Well within 60-second window

Token Age: 59 seconds (timestamp = 941)
Status: ‚úÖ ACCEPTED (near expiration)
Reason: Just barely within 60-second window

Token Age: 60 seconds (timestamp = 940)
Status: ‚úÖ ACCEPTED (exact boundary)
Reason: Exactly at lower bound (inclusive)

Token Age: 61 seconds (timestamp = 939)
Status: ‚ùå REJECTED (expired)
Reason: Exceeds 60-second maximum age


CLOCK SKEW HANDLING
--------------------

Real-World Scenario:
- GCSplit Server Clock: 2024-11-05 22:34:05 UTC
- GCHostPay Server Clock: 2024-11-05 22:34:12 UTC (7 seconds ahead)

Token Flow:
1. GCSplit creates token at 22:34:05 (GCSplit time)
   - Embedded timestamp: 1730841645
2. Token transmitted to GCHostPay (travel time: 1 second)
3. GCHostPay receives at 22:34:06 (GCSplit time) / 22:34:13 (GCHostPay time)
4. GCHostPay validates:
   - current_time = 1730841653 (GCHostPay's clock)
   - timestamp = 1730841645 (embedded in token)
   - Apparent age: 8 seconds
   - Valid range: 1730841593 to 1730841658
   - Validation: 1730841593 <= 1730841645 <= 1730841658 ‚úÖ VALID

Without Grace Period (Hypothetical):
- Token would appear to be -7 seconds old (from future)
- Would be rejected as invalid
- System would break due to normal clock drift

With 5-Second Grace Period:
- Accommodates clock differences up to 5 seconds
- System remains operational despite minor time sync issues
- Still prevents significant replay attacks


ATTACK SCENARIOS AND DEFENSES
------------------------------

Attack 1: Replay Attack
Scenario:
- Attacker intercepts valid token at T=1000
- Attacker tries to replay token at T=1070 (70 seconds later)

Defense:
- Token timestamp: 1000
- Current time: 1070
- Token age: 70 seconds
- Validation: 1010 <= 1000 <= 1075 ‚ùå REJECTED (too old)

Result: Attack fails


Attack 2: Preemptive Token Creation
Scenario:
- Attacker creates token with future timestamp (T=1100)
- Attacker tries to use at T=1050

Defense:
- Token timestamp: 1100
- Current time: 1050
- Token age: -50 seconds (future)
- Validation: 990 <= 1100 <= 1055 ‚ùå REJECTED (too far in future)

Result: Attack fails


Attack 3: Token Modification
Scenario:
- Attacker intercepts valid token
- Attacker changes from_amount to higher value
- Attacker replays modified token

Defense:
- Signature verification detects modification
- HMAC mismatch ‚Üí ValueError("Signature mismatch")
- Token rejected before timestamp check

Result: Attack fails


Attack 4: Slow Lorris (Delayed Replay)
Scenario:
- Attacker intercepts token at T=1000
- Attacker delays network packet for 55 seconds
- Token arrives at T=1055

Defense:
- Token timestamp: 1000
- Current time: 1055
- Token age: 55 seconds
- Validation: 995 <= 1000 <= 1060 ‚úÖ ACCEPTED

Result: Attack succeeds BUT:
- ChangeNow transaction likely expired (status != "waiting")
- GCHostPay checks ChangeNow status before payment
- Payment rejected due to expired ChangeNow transaction
- Attacker gains nothing


OPERATIONAL TIMING BUDGET
--------------------------

Component Timing Analysis:

1. ChangeNow Transaction Creation: 2-5 seconds
   - API request/response latency

2. Token Generation (GCSplit): < 0.1 seconds
   - Binary packing
   - HMAC calculation
   - Base64 encoding

3. HTTP Request (GCSplit ‚Üí GCHostPay): 0.2-2 seconds
   - Network latency (same region)
   - DNS, TCP, TLS overhead

4. Token Decoding (GCHostPay): < 0.1 seconds
   - Base64 decoding
   - Binary unpacking
   - HMAC verification
   - Timestamp check

5. ChangeNow Status Check: 1-3 seconds
   - API request to ChangeNow
   - Status validation

6. Database Duplicate Check: 0.1-0.5 seconds
   - Query split_payout_hostpay table

7. ETH Transaction Broadcasting: 2-5 seconds
   - Web3 provider interaction
   - Gas estimation
   - Transaction signing
   - Broadcasting to Ethereum network

Total Expected Time: 6-16 seconds
Typical Time: ~10 seconds

Timing Budget vs. Expiration:
- 60-second window
- ~10 seconds typical processing
- 50 seconds safety margin
- Accommodates retries, network congestion, server load


REAL-WORLD TIMING LOGS
-----------------------

Successful Case (Fast):
```
‚è∞ [HOSTPAY_TOKEN] Timestamp: 1730841645  (22:34:05 UTC)
   [Network transmission: 1.2 seconds]
‚è∞ [TOKEN_VALIDATION] Token age: 3 seconds (22:34:08 UTC)
   ‚úÖ VALID - Processed in 3 seconds
```

Successful Case (Normal):
```
‚è∞ [HOSTPAY_TOKEN] Timestamp: 1730841600  (22:33:20 UTC)
   [Network transmission: 2.5 seconds]
   [ChangeNow status check: 3.1 seconds]
‚è∞ [TOKEN_VALIDATION] Token age: 8 seconds (22:33:28 UTC)
   ‚úÖ VALID - Processed in 8 seconds
```

Successful Case (Slow but Valid):
```
‚è∞ [HOSTPAY_TOKEN] Timestamp: 1730841500  (22:31:40 UTC)
   [Network congestion: 15 seconds]
   [Server load: 25 seconds processing delay]
‚è∞ [TOKEN_VALIDATION] Token age: 45 seconds (22:32:25 UTC)
   ‚úÖ VALID - Processed in 45 seconds (within 60s window)
```

Failed Case (Expired):
```
‚è∞ [HOSTPAY_TOKEN] Timestamp: 1730841400  (22:30:00 UTC)
   [Service outage: 80 seconds]
‚è∞ [TOKEN_VALIDATION] Token age: 80 seconds (22:31:20 UTC)
   ‚ùå REJECTED - Token expired (created 80 seconds ago, max 60 seconds)
```


WHY 60 SECONDS?
---------------

Too Short (e.g., 10 seconds):
‚ùå Not enough time for network latency
‚ùå Fails during normal load spikes
‚ùå No room for retries on transient errors
‚ùå Requires perfect network conditions

Too Long (e.g., 300 seconds):
‚ùå Increases replay attack window
‚ùå ChangeNow transactions may expire
‚ùå Database state may change (duplicate payments)
‚ùå Weakens security guarantees

Just Right (60 seconds):
‚úÖ Accommodates network issues
‚úÖ Allows for retries
‚úÖ Matches ChangeNow transaction lifecycle
‚úÖ Limits replay attack surface
‚úÖ Provides operational flexibility
‚úÖ Balances security and reliability


MONITORING AND ALERTS
----------------------

Recommended Monitoring:

1. Average Token Age at Validation
   - Normal: 2-15 seconds
   - Warning: 30-45 seconds
   - Critical: > 50 seconds

2. Token Expiration Rate
   - Normal: < 0.1% expired
   - Warning: 0.1-1% expired
   - Critical: > 1% expired

3. Clock Skew Detection
   - Measure: |server1_time - server2_time|
   - Normal: < 2 seconds
   - Warning: 2-4 seconds
   - Critical: > 4 seconds

Alert Examples:
‚ö†Ô∏è "Token validation taking > 30 seconds (current: 42s)"
‚ö†Ô∏è "Clock skew detected: 7 seconds between GCSplit and GCHostPay"
üö® "5% of tokens expired in last hour - investigate delays"


================================================================================
8. SECURITY MECHANISMS
================================================================================

The GCSplit ‚Üí GCHostPay token system employs multiple layers of security.


LAYER 1: HMAC-SHA256 SIGNATURE
-------------------------------

Mechanism: HMAC (Hash-based Message Authentication Code)

Purpose:
‚úÖ Verify token authenticity (came from trusted source)
‚úÖ Detect tampering (any modification invalidates signature)
‚úÖ Prevent forgery (cannot create valid tokens without key)

Implementation:
```python
# Generation (GCSplit)
signature = hmac.new(signing_key.encode(), data, hashlib.sha256).digest()[:16]

# Verification (GCHostPay)
expected_sig = hmac.new(signing_key.encode(), data, hashlib.sha256).digest()[:16]
if not hmac.compare_digest(sig, expected_sig):
    raise ValueError("Signature mismatch")
```

Security Properties:
- Key length: 256+ bits recommended
- Hash: SHA-256 (cryptographically secure)
- Truncation: 128 bits (16 bytes) still secure
- Comparison: Constant-time (prevents timing attacks)

Attack Resistance:
‚ùå Brute force: 2^128 = 3.4√ó10¬≥‚Å∏ attempts (infeasible)
‚ùå Collision: SHA-256 collision resistance
‚ùå Forgery: Requires knowing signing_key
‚ùå Timing: hmac.compare_digest() prevents side-channel


LAYER 2: TIME-BASED EXPIRATION
-------------------------------

Mechanism: Embedded Unix timestamp + validation window

Purpose:
‚úÖ Prevent replay attacks (old tokens rejected)
‚úÖ Enforce temporal coupling (payment must happen soon)
‚úÖ Limit attack surface (60-second window)
‚úÖ Align with ChangeNow transaction lifecycle

Implementation:
```python
# Generation (GCSplit)
timestamp = int(time.time())  # Current time

# Verification (GCHostPay)
current_time = int(time.time())
if not (current_time - 60 <= timestamp <= current_time + 5):
    raise ValueError("Token expired")
```

Security Properties:
- Expiration: 60 seconds from creation
- Grace: 5 seconds for clock skew
- Resolution: 1 second (Unix timestamp)

Attack Resistance:
‚ùå Replay: Old tokens expire automatically
‚ùå Preemption: Future tokens rejected
‚ùå Interception: Limited usefulness (60s window)


LAYER 3: REQUEST-RESPONSE PATTERN
----------------------------------

Mechanism: Synchronous HTTP POST with immediate validation

Purpose:
‚úÖ Immediate validation (no queuing old requests)
‚úÖ Clear success/failure (no ambiguity)
‚úÖ Idempotency support (check duplicate transactions)

Implementation:
```python
# GCSplit sends request
response = requests.post(hostpay_webhook_url, json={"token": token}, timeout=30)

# GCHostPay responds immediately
if token_valid:
    return jsonify({"status": "success"}), 200
else:
    return jsonify({"status": "error", "message": "Invalid token"}), 400
```

Security Properties:
- Timeout: 30 seconds max
- Synchronous: No queuing delays
- Immediate validation: Token checked before processing

Operational Benefits:
‚úÖ Fast feedback (know immediately if token accepted)
‚úÖ No orphaned requests (timeout prevents hanging)
‚úÖ Simple error handling (HTTP status codes)


LAYER 4: DATABASE DUPLICATE PREVENTION
---------------------------------------

Mechanism: Check unique_id before processing

Purpose:
‚úÖ Prevent duplicate payments (same transaction paid twice)
‚úÖ Idempotency (safe to retry webhook calls)
‚úÖ Audit trail (detect replay attempts)

Implementation:
```python
# Check if transaction already processed
if db_manager.check_transaction_exists(unique_id):
    print(f"‚ö†Ô∏è Transaction {unique_id} already processed - skipping")
    return jsonify({"status": "already_processed"}), 200
```

Security Properties:
- Primary key: unique_id (16-char string)
- Check before payment: No double-spend
- Idempotent: Safe to retry webhook

Attack Resistance:
‚ùå Duplicate payment: Detected and rejected
‚ùå Race condition: Database UNIQUE constraint
‚ùå Replay with new token: Same unique_id detected


LAYER 5: CHANGENOW STATUS VERIFICATION
---------------------------------------

Mechanism: Query ChangeNow API for transaction status

Purpose:
‚úÖ Verify transaction is still waiting for payment
‚úÖ Prevent payment to expired transactions
‚úÖ Align with ChangeNow state machine

Implementation:
```python
cn_status = check_changenow_status(cn_api_id)
if cn_status != "waiting":
    print(f"‚ö†Ô∏è ChangeNow status is '{cn_status}' - expected 'waiting'")
    return jsonify({"status": "invalid_status"}), 400
```

Security Properties:
- External validation: Independent check
- State verification: Must be "waiting"
- Fail-safe: Don't pay if transaction invalid

Transaction States:
- "waiting" ‚úÖ Ready for payment
- "confirming" ‚ö†Ô∏è Already paid (reject)
- "exchanging" ‚ö†Ô∏è Already processing (reject)
- "finished" ‚ö†Ô∏è Already complete (reject)
- "failed" ‚ùå Transaction failed (reject)
- "expired" ‚ùå Transaction expired (reject)


LAYER 6: BINARY FORMAT VALIDATION
----------------------------------

Mechanism: Strict parsing with bounds checking

Purpose:
‚úÖ Prevent buffer overflow attacks
‚úÖ Detect corrupted tokens early
‚úÖ Enforce format constraints

Implementation:
```python
# Size check
if len(raw) < 52:
    raise ValueError("Invalid token: too small")

# Bounds checking for each field
if offset + field_length > len(raw):
    raise ValueError("Invalid token: incomplete field")
```

Security Properties:
- Minimum size: 52 bytes
- Bounds checking: Every field validated
- Early rejection: Invalid tokens never processed

Attack Resistance:
‚ùå Buffer overflow: Bounds checking prevents
‚ùå Malformed data: Detected during parsing
‚ùå Corrupted tokens: Rejected before processing


COMBINED SECURITY ANALYSIS
---------------------------

Attack: Replay Old Token
Defense Stack:
1. ‚è∞ Time validation: Rejected (> 60 seconds old)
2. üíæ Database check: May detect duplicate unique_id
3. üîÑ ChangeNow status: Transaction likely expired

Result: ‚ùå Attack fails at step 1


Attack: Modify Token Amount
Defense Stack:
1. üîê HMAC verification: Rejected (signature mismatch)
2. Never reaches time validation

Result: ‚ùå Attack fails at step 1


Attack: Create Fake Token
Defense Stack:
1. üîê HMAC verification: Rejected (no valid signing key)
2. Cannot forge valid signature

Result: ‚ùå Attack fails at step 1


Attack: Intercept and Delay Token
Defense Stack:
1. ‚è∞ Time validation: Rejected if delay > 60s
2. üîÑ ChangeNow status: Transaction likely expired
3. üíæ Database: May already be processed

Result: ‚ö†Ô∏è May pass time validation if delay < 60s
        ‚ùå Fails ChangeNow status check (expired)


SECURITY BEST PRACTICES
------------------------

1. Signing Key Management
   ‚úÖ Store in Google Cloud Secret Manager
   ‚úÖ Rotate periodically (quarterly recommended)
   ‚úÖ Use strong random key (256+ bits)
   ‚úÖ Never commit to version control
   ‚úÖ Same key shared between GCSplit and GCHostPay

2. Time Synchronization
   ‚úÖ Use NTP on all servers
   ‚úÖ Monitor clock drift
   ‚úÖ Alert if drift > 2 seconds
   ‚úÖ Consider using Google Cloud's time service

3. Logging and Monitoring
   ‚úÖ Log all token validations (success and failure)
   ‚úÖ Monitor expiration rate (< 1% normal)
   ‚úÖ Alert on signature mismatches (may indicate attack)
   ‚úÖ Track token age distribution

4. Network Security
   ‚úÖ Use HTTPS for all webhook communications
   ‚úÖ Verify TLS certificates
   ‚úÖ Use VPC for internal communication (if possible)
   ‚úÖ Implement rate limiting on webhook endpoints

5. Error Handling
   ‚úÖ Return generic errors to client (no leak details)
   ‚úÖ Log detailed errors server-side
   ‚úÖ Implement exponential backoff for retries
   ‚úÖ Set max retry attempts (3-5 recommended)


================================================================================
9. FAILURE SCENARIOS
================================================================================

This section covers common and edge-case failure modes.


SCENARIO 1: Token Expired (> 60 seconds)
-----------------------------------------

Cause:
- Network delay
- Service downtime
- Processing backlog

Symptom:
```
‚ùå [HOSTPAY_WEBHOOK] Token validation failed: Token expired (created 75 seconds ago, max 60 seconds)
```

HTTP Response: 400 Bad Request

Impact:
- ETH payment not executed
- ChangeNow transaction likely expired
- Client payout not processed

Recovery:
- GCSplit logs warning (non-fatal)
- Manual intervention may be needed
- Admin can create new ChangeNow transaction

Prevention:
- Monitor token age distribution
- Alert if average age > 30 seconds
- Investigate service delays


SCENARIO 2: Signature Mismatch
-------------------------------

Cause:
- Token tampered with
- Wrong signing key configured
- Token corrupted during transmission

Symptom:
```
‚ùå [HOSTPAY_WEBHOOK] Token validation failed: Signature mismatch - token may be tampered or invalid signing key
```

HTTP Response: 400 Bad Request

Impact:
- ETH payment not executed
- Token rejected immediately

Recovery:
- Verify signing key matches between services
- Check Secret Manager configuration
- Retry with fresh token

Prevention:
- Use Secret Manager for key management
- Automate key rotation with update scripts
- Test key validity during deployment


SCENARIO 3: ChangeNow Transaction Not "waiting"
------------------------------------------------

Cause:
- Token delayed > ChangeNow timeout
- Transaction already paid by another source
- ChangeNow transaction failed/expired

Symptom:
```
‚ö†Ô∏è [HOSTPAY_WEBHOOK] ChangeNow status is 'expired' - expected 'waiting'
üõë [HOSTPAY_WEBHOOK] Terminating execution for unique_id: AH7CWKX82NCPIII9
```

HTTP Response: 400 Bad Request

Impact:
- ETH payment prevented (correct behavior)
- Avoids paying to invalid transaction

Recovery:
- Create new ChangeNow transaction
- Generate new token
- Retry entire flow

Prevention:
- Process tokens quickly (< 20 seconds typical)
- Monitor ChangeNow transaction lifetimes
- Alert on frequent transaction expirations


SCENARIO 4: Duplicate Transaction (unique_id exists)
-----------------------------------------------------

Cause:
- Webhook retry (intentional)
- Network issue caused duplicate request
- Manual replay for testing

Symptom:
```
‚ö†Ô∏è [HOSTPAY_WEBHOOK] Transaction AH7CWKX82NCPIII9 already processed - skipping
```

HTTP Response: 200 OK (idempotent)

Impact:
- No duplicate payment (correct behavior)
- Safe idempotency

Recovery:
- None needed (working as designed)

Prevention:
- This is expected behavior for retries
- Database UNIQUE constraint ensures safety


SCENARIO 5: Wallet Manager ETH Payment Fails
---------------------------------------------

Cause:
- Insufficient ETH balance in host wallet
- Gas price spike
- Ethereum network congestion
- Invalid payin_address

Symptom:
```
‚ùå [HOSTPAY_WEBHOOK] ETH payment failed
```

HTTP Response: 500 Internal Server Error

Impact:
- ChangeNow transaction not paid
- Client payout blocked
- Requires manual intervention

Recovery:
- Check host wallet balance
- Verify Ethereum RPC connectivity
- Retry with higher gas price
- Manual payment if automated fails

Prevention:
- Monitor host wallet balance
- Alert if balance < 0.5 ETH
- Implement automatic balance top-up
- Use gas price oracles for estimation


SCENARIO 6: Database Insert Fails
----------------------------------

Cause:
- Database connection error
- Cloud SQL instance down
- Constraint violation (rare)

Symptom:
```
‚ö†Ô∏è [HOSTPAY_DB] Database error inserting hostpay transaction: [error details]
‚ö†Ô∏è [HOSTPAY_WEBHOOK] Database logging failed (non-fatal)
```

HTTP Response: 200 OK (ETH payment succeeded)

Impact:
- ETH payment completed successfully
- Database record missing
- Audit trail incomplete

Recovery:
- Manual database entry using transaction data
- Retrieve from Ethereum transaction logs

Prevention:
- Monitor database health
- Implement connection pooling
- Add retry logic for database operations


SCENARIO 7: Network Timeout (30 seconds)
-----------------------------------------

Cause:
- Severe network congestion
- GCHostPay service overloaded
- Firewall/routing issue

Symptom:
```
‚ùå [HOSTPAY_WEBHOOK] Request timeout
```

HTTP Response: None (timeout exception)

Impact:
- Unknown state (payment may or may not have been executed)
- Requires status check

Recovery:
- Check database for unique_id
- Query Ethereum for pending transactions
- Safe to retry (idempotency protection)

Prevention:
- Monitor network latency
- Scale GCHostPay service (auto-scaling)
- Investigate routing issues


SCENARIO 8: Malformed Token
----------------------------

Cause:
- Base64 encoding error
- Corrupted data transmission
- Version mismatch (different packing format)

Symptom:
```
‚ùå [HOSTPAY_WEBHOOK] Token validation failed: Invalid token: cannot decode base64
```

HTTP Response: 400 Bad Request

Impact:
- Token rejected immediately
- No processing attempted

Recovery:
- Regenerate token with correct encoding
- Verify GCSplit version matches GCHostPay

Prevention:
- Use URL-safe base64 encoding
- Add version field to token format
- Test token generation in staging


ERROR RATE BENCHMARKS
----------------------

Normal Operation:
- Token expiration: < 0.1%
- Signature mismatch: < 0.01%
- Duplicate transactions: 1-5% (retries expected)
- ChangeNow status mismatch: < 0.5%
- ETH payment failures: < 1%
- Database errors: < 0.1%

Warning Thresholds:
- Token expiration: > 1%
- Signature mismatch: > 0.1%
- ETH payment failures: > 5%
- Database errors: > 1%

Critical Thresholds:
- Token expiration: > 5%
- Any category > 10%


================================================================================
10. CODE REFERENCES
================================================================================

GCSPLIT10-21 (Token Generation)
--------------------------------

1. tps10-21.py:142-235
   - build_hostpay_token()
   - Generates binary packed token
   - Signs with HMAC-SHA256
   - Returns base64 encoded string

2. tps10-21.py:237-317
   - trigger_hostpay_webhook()
   - Sends POST request to GCHostPay
   - Handles response and errors
   - Returns success/failure boolean

3. tps10-21.py:319-458
   - create_fixed_rate_transaction()
   - Creates ChangeNow transaction
   - Saves to split_payout_que
   - Calls trigger_hostpay_webhook()

4. tps10-21.py:699-838
   - process_payment_split()
   - Main workflow orchestration
   - Calls all helper functions
   - Returns processing result


GCHOSTPAY10-21 (Token Decoding)
--------------------------------

1. tphp10-21.py:143-270
   - decode_and_verify_hostpay_token()
   - Base64 decodes token
   - Parses binary structure
   - Verifies HMAC signature
   - Validates timestamp (‚è∞ TIME CHECK)
   - Returns extracted values

2. tphp10-21.py:272-421
   - hostpay_webhook()
   - Receives POST request
   - Calls decode_and_verify_hostpay_token()
   - Checks ChangeNow status
   - Executes ETH payment
   - Logs to database

3. tphp10-21.py:92-141
   - check_changenow_status()
   - Queries ChangeNow API
   - Returns transaction status
   - Used to verify "waiting" status


SHARED COMPONENTS
-----------------

1. Config Manager (GCSplit)
   - config_manager.py
   - Fetches secrets from Google Secret Manager
   - Provides configuration to services

2. Database Manager (GCHostPay)
   - database_manager.py
   - Handles split_payout_hostpay table
   - Checks for duplicate transactions
   - Inserts completed payments

3. Wallet Manager (GCHostPay)
   - wallet_manager.py
   - Executes ETH transactions
   - Handles gas optimization
   - Returns tx_hash, gas_used, block_number


ENVIRONMENT VARIABLES
---------------------

GCSplit10-21:
- HOSTPAY_WEBHOOK_URL
  Path: projects/*/secrets/hostpay_webhook_url/versions/latest
  Value: https://tphp10-21-xxx.run.app

- TPS_HOSTPAY_SIGNING_KEY
  Path: projects/*/secrets/tps_hostpay_signing_key/versions/latest
  Value: [shared HMAC key]

GCHostPay10-21:
- TPS_HOSTPAY_SIGNING_KEY
  Path: projects/*/secrets/tps_hostpay_signing_key/versions/latest
  Value: [shared HMAC key - MUST MATCH GCSplit]

- HOST_WALLET_ETH_ADDRESS
  Path: projects/*/secrets/host_wallet_eth_address/versions/latest

- HOST_WALLET_PRIVATE_KEY
  Path: projects/*/secrets/host_wallet_private_key/versions/latest

- ETHEREUM_RPC_URL
  Path: projects/*/secrets/ethereum_rpc_url/versions/latest


================================================================================
11. TIMING DIAGRAMS
================================================================================

NORMAL FLOW (Fast Processing)
------------------------------

Time: 0s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCSplit10-21: ChangeNow API Response Received ‚îÇ
‚îÇ cn_api_id: ec4b26e3a392e6                     ‚îÇ
‚îÇ payin_address: 0x1D70FD91E9...                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì

Time: 0.05s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCSplit10-21: build_hostpay_token()           ‚îÇ
‚îÇ ‚è∞ TIMESTAMP EMBEDDED: 1730841645             ‚îÇ
‚îÇ TOKEN AGE: 0 seconds                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì

Time: 0.1s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCSplit10-21: trigger_hostpay_webhook()       ‚îÇ
‚îÇ POST https://tphp10-21-xxx.run.app            ‚îÇ
‚îÇ Payload: {"token": "QUg3Q1dL..."}             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì [Network: 0.5s]

Time: 0.6s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCHostPay10-21: Webhook Request Received      ‚îÇ
‚îÇ TOKEN AGE: 0.55 seconds                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì

Time: 0.7s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCHostPay10-21: decode_and_verify_token()     ‚îÇ
‚îÇ ‚è∞ TIMESTAMP CHECK: 0.65s old ‚úÖ VALID        ‚îÇ
‚îÇ Signature verification: ‚úÖ PASSED             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì

Time: 1.5s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCHostPay10-21: check_changenow_status()      ‚îÇ
‚îÇ Status: "waiting" ‚úÖ Ready for payment        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì

Time: 3.2s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCHostPay10-21: send_eth_payment()            ‚îÇ
‚îÇ Broadcasting ETH transaction...               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì

Time: 8.5s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCHostPay10-21: ETH Transaction Confirmed     ‚îÇ
‚îÇ tx_hash: 0x99a936f95ee27b...                  ‚îÇ
‚îÇ gas_used: 21000                               ‚îÇ
‚îÇ block_number: 23632807                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì

Time: 8.7s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCHostPay10-21: Database Insert Complete      ‚îÇ
‚îÇ Table: split_payout_hostpay                   ‚îÇ
‚îÇ unique_id: AH7CWKX82NCPIII9                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì

Time: 8.8s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCHostPay10-21: HTTP 200 OK Response Sent     ‚îÇ
‚îÇ ‚úÖ WEBHOOK COMPLETE                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Total Time: 8.8 seconds
Token Age at Validation: 0.65 seconds ‚úÖ
Final Token Age: 8.75 seconds ‚úÖ


DELAYED FLOW (Network Congestion)
----------------------------------

Time: 0s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCSplit10-21: Token Generated                 ‚îÇ
‚îÇ ‚è∞ TIMESTAMP: 1730841600                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì [Network Delay: 35s]

Time: 35s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCHostPay10-21: Request Received              ‚îÇ
‚îÇ ‚è∞ TOKEN AGE: 35 seconds                      ‚îÇ
‚îÇ ‚è∞ VALIDATION: 35 < 60 ‚úÖ STILL VALID         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì [Processing: 10s]

Time: 45s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCHostPay10-21: Payment Complete              ‚îÇ
‚îÇ ‚è∞ FINAL TOKEN AGE: 45 seconds ‚úÖ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


EXPIRED FLOW (Service Outage)
------------------------------

Time: 0s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCSplit10-21: Token Generated                 ‚îÇ
‚îÇ ‚è∞ TIMESTAMP: 1730841400                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì [Service Down: 80s]

Time: 80s
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCHostPay10-21: Service Restored              ‚îÇ
‚îÇ Request Received (Retry)                      ‚îÇ
‚îÇ ‚è∞ TOKEN AGE: 80 seconds                      ‚îÇ
‚îÇ ‚è∞ VALIDATION: 80 > 60 ‚ùå EXPIRED             ‚îÇ
‚îÇ ‚ùå REJECTED: "Token expired"                  ‚îÇ
‚îÇ HTTP 400 Bad Request                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


CLOCK SKEW SCENARIO
-------------------

GCSplit Clock: 10:00:00 UTC
GCHostPay Clock: 10:00:08 UTC (8 seconds ahead)

Time: 0s (GCSplit Time)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCSplit10-21: Token Generated                 ‚îÇ
‚îÇ ‚è∞ TIMESTAMP: 1730841600 (10:00:00 GCSplit)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì [Network: 1s]

Time: 1s (GCSplit) / 9s (GCHostPay)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GCHostPay10-21: Request Received              ‚îÇ
‚îÇ GCHostPay Clock: 10:00:09                     ‚îÇ
‚îÇ Token Timestamp: 10:00:00 (GCSplit)           ‚îÇ
‚îÇ ‚è∞ APPARENT AGE: 9 seconds                    ‚îÇ
‚îÇ ‚è∞ GRACE PERIOD: +5 seconds                   ‚îÇ
‚îÇ ‚è∞ VALIDATION: 9 > 5 but < 60 ‚úÖ VALID        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


================================================================================
12. BEST PRACTICES
================================================================================

DEVELOPMENT
-----------

1. Token Testing
   ‚úÖ Write unit tests for build_hostpay_token()
   ‚úÖ Write unit tests for decode_and_verify_hostpay_token()
   ‚úÖ Test with various timestamp ages (0s, 30s, 59s, 61s)
   ‚úÖ Test signature verification with wrong keys
   ‚úÖ Test with malformed tokens (truncated, corrupted)

2. Local Testing
   ‚úÖ Use fixed timestamps for reproducibility
   ‚úÖ Mock time.time() to test expiration logic
   ‚úÖ Use test signing key (never production key in code)
   ‚úÖ Log all token generation/validation steps

3. Integration Testing
   ‚úÖ Test full flow: GCSplit ‚Üí GCHostPay ‚Üí ETH payment
   ‚úÖ Test retry logic (intentional token reuse)
   ‚úÖ Test ChangeNow status variations
   ‚úÖ Test database duplicate detection


DEPLOYMENT
----------

1. Configuration Management
   ‚úÖ Use Google Secret Manager for all keys
   ‚úÖ Rotate signing keys quarterly
   ‚úÖ Update both services simultaneously during rotation
   ‚úÖ Verify key sync between GCSplit and GCHostPay

2. Monitoring Setup
   ‚úÖ Track average token age at validation
   ‚úÖ Alert if token age > 30 seconds
   ‚úÖ Monitor token expiration rate (< 1% normal)
   ‚úÖ Track signature mismatch rate (< 0.01% normal)
   ‚úÖ Monitor webhook success rate (> 99% target)

3. Logging Configuration
   ‚úÖ Log all token validations (success and failure)
   ‚úÖ Log token age at validation time
   ‚úÖ Log ChangeNow status checks
   ‚úÖ Log ETH transaction hashes
   ‚úÖ Use structured logging (JSON format)


OPERATIONS
----------

1. Incident Response
   ‚úÖ If token expiration rate spikes ‚Üí Check service health
   ‚úÖ If signature mismatches ‚Üí Verify key sync
   ‚úÖ If ETH payments failing ‚Üí Check wallet balance
   ‚úÖ If ChangeNow rejections ‚Üí Check transaction lifetimes

2. Performance Optimization
   ‚úÖ Monitor token validation latency (< 100ms target)
   ‚úÖ Monitor webhook request latency (< 2s target)
   ‚úÖ Optimize database queries (indexed lookups)
   ‚úÖ Use connection pooling for database

3. Capacity Planning
   ‚úÖ Estimate webhook throughput (requests/second)
   ‚úÖ Plan for 3x peak load capacity
   ‚úÖ Monitor GCHostPay CPU and memory usage
   ‚úÖ Enable auto-scaling on Cloud Run


SECURITY
--------

1. Key Management
   ‚úÖ Never commit keys to version control
   ‚úÖ Use different keys for dev/staging/prod
   ‚úÖ Implement key rotation procedure
   ‚úÖ Log all key access (Secret Manager audit logs)

2. Network Security
   ‚úÖ Use HTTPS for all webhook communications
   ‚úÖ Verify TLS certificates (no self-signed in prod)
   ‚úÖ Consider VPC for internal communication
   ‚úÖ Implement rate limiting (100 req/min per IP)

3. Monitoring and Alerts
   ‚úÖ Alert on unusual spike in validation failures
   ‚úÖ Alert on signature mismatch (possible attack)
   ‚úÖ Monitor for replay attempts (duplicate unique_id)
   ‚úÖ Review logs daily for anomalies


DOCUMENTATION
-------------

1. Runbooks
   ‚úÖ Document token expiration investigation steps
   ‚úÖ Document key rotation procedure
   ‚úÖ Document common failure scenarios and fixes
   ‚úÖ Document escalation procedures

2. Architecture Diagrams
   ‚úÖ Maintain up-to-date flow diagrams
   ‚úÖ Document all webhook endpoints
   ‚úÖ Document database schema changes
   ‚úÖ Document token format versions

3. API Documentation
   ‚úÖ Document webhook payload format
   ‚úÖ Document response codes and meanings
   ‚úÖ Document retry behavior and idempotency
   ‚úÖ Document rate limits and quotas


================================================================================
SUMMARY
================================================================================

The GCSplit ‚Üí GCHostPay token flow is a TIME-SENSITIVE security mechanism
that enables automated ETH payments while preventing replay attacks and
ensuring transaction integrity.

Key Takeaways:

‚è∞ TIME SENSITIVITY: 60-second expiration window
   - Prevents replay attacks
   - Aligns with ChangeNow transaction lifecycle
   - Provides operational flexibility

üîê SECURITY: Multi-layered protection
   - HMAC-SHA256 signature (128-bit truncated)
   - Time-based expiration
   - Database duplicate prevention
   - ChangeNow status verification

üì¶ EFFICIENCY: Binary packed format
   - Compact size (~120 bytes)
   - Fast parsing
   - No ambiguity

üõ°Ô∏è RELIABILITY: Defensive design
   - Idempotent webhooks
   - Clear error messages
   - Comprehensive logging
   - Graceful failure handling

‚ö° PERFORMANCE: Fast processing
   - Typical token age: 2-15 seconds
   - Total workflow: 8-16 seconds
   - 50-second safety margin

This document provides complete technical details for understanding,
implementing, debugging, and maintaining the token-based webhook system.

================================================================================
END OF DOCUMENTATION
================================================================================

Generated: October 2025
Last Updated: 2025-10-23
Version: 10-18
For: TelegramFunnel Payment System

Related Documentation:
- INVITATION_LINK_WORKFLOW.txt - User invitation flow
- SUCCESS_URL_FLOW_EXPLANATION.txt - Success URL token format
- ENVIRONMENT_VARIABLES.txt - Configuration reference

For questions about token generation or time-sensitive validation:
- GCSplit10-21/tps10-21.py (token generation)
- GCHostPay10-21/tphp10-21.py (token validation)
- Contact: System Administrator

================================================================================
