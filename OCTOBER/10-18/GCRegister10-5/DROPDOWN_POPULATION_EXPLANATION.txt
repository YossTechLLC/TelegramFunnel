===============================================================================
NETWORK TYPE & PAYOUT CURRENCY DROPDOWN POPULATION EXPLANATION
===============================================================================
Service: GCRegister10-5 (Channel Registration Webhook)
Date: 2025-10-24
Purpose: Explain how dropdown menus are populated in the registration form

===============================================================================
üìã OVERVIEW
===============================================================================

The registration form presents two critical dropdown menus to users:
1. üåê Network Type (e.g., SOL, ETH, BNB, MATIC, etc.)
2. üí∞ Payout Currency (e.g., USDT, USDC, BTC, ETH, etc.)

These dropdowns are populated DYNAMICALLY from a PostgreSQL database table
called `currency_to_network`, which contains all valid currency-network pairs
supported by the ChangeNow cryptocurrency exchange API.

The dropdowns feature BIDIRECTIONAL FILTERING:
- Selecting a Network filters available Currencies
- Selecting a Currency filters available Networks


===============================================================================
üóÑÔ∏è DATA SOURCE: currency_to_network TABLE
===============================================================================

Database: PostgreSQL (Cloud SQL instance: telepay-459221:us-central1:telepaypsql)
Table Name: currency_to_network

Schema:
--------
CREATE TABLE currency_to_network (
    id SERIAL PRIMARY KEY,
    currency VARCHAR(6) NOT NULL,
    network VARCHAR(8) NOT NULL,
    UNIQUE(currency, network)
);

Sample Data (196 total mappings):
----------------------------------
| currency | network |
|----------|---------|
| USDT     | SOL     |
| USDT     | ETH     |
| USDT     | BNB     |
| USDT     | MATIC   |
| USDT     | TRX     |
| BTC      | BTC     |
| ETH      | ETH     |
| SOL      | SOL     |
| USDC     | SOL     |
| USDC     | ETH     |
| ...      | ...     |

Purpose:
--------
This table maps which cryptocurrencies are available on which blockchain
networks. For example:
- USDT exists on SOL (Solana), ETH (Ethereum), BNB (BNB Chain), etc.
- BTC only exists on BTC (Bitcoin network)
- Native tokens like SOL only exist on their own network (SOL)

This ensures users can only select valid currency-network combinations that
are actually supported by ChangeNow for cryptocurrency conversions.


===============================================================================
üîÑ DATA FLOW: FROM DATABASE TO USER INTERFACE
===============================================================================

STEP 1: Database Query (database_manager.py)
---------------------------------------------
File: database_manager.py
Method: get_currency_to_network_mappings() [Lines 226-284]

When called, this method:
1. Executes SQL query:
   SELECT currency, network FROM currency_to_network ORDER BY network, currency

2. Builds three data structures:
   a) mappings: List of all {currency, network} pairs
   b) network_to_currencies: Dictionary mapping each network to its currencies
   c) currency_to_networks: Dictionary mapping each currency to its networks

Example Output:
{
    "mappings": [
        {"currency": "USDT", "network": "SOL"},
        {"currency": "USDT", "network": "ETH"},
        {"currency": "BTC", "network": "BTC"},
        ...
    ],
    "network_to_currencies": {
        "SOL": ["USDT", "USDC", "SOL", ...],
        "ETH": ["USDT", "USDC", "ETH", "DAI", ...],
        "BNB": ["USDT", "BNB", ...],
        ...
    },
    "currency_to_networks": {
        "USDT": ["SOL", "ETH", "BNB", "MATIC", "TRX", ...],
        "BTC": ["BTC"],
        "ETH": ["ETH"],
        ...
    }
}


STEP 2: API Endpoint (app.py)
------------------------------
File: app.py
Route: /api/currency-network-mappings [Lines 205-244]
HTTP Method: GET
Returns: JSON

When the registration page loads, JavaScript makes a fetch request to this endpoint.

Request:
GET https://gcregister10-23-XXXXXXXXX-uc.a.run.app/api/currency-network-mappings

Response (200 OK):
{
    "success": true,
    "data": {
        "mappings": [...],
        "network_to_currencies": {...},
        "currency_to_networks": {...}
    }
}

The endpoint:
1. Checks if database manager is available
2. Calls db_manager.get_currency_to_network_mappings()
3. Returns the data as JSON with success flag
4. Handles errors (returns 503 if DB unavailable, 404 if no mappings, 500 on error)


STEP 3: JavaScript Fetch (register.html)
-----------------------------------------
File: templates/register.html
Lines: 266-291

On page load, JavaScript executes:

async function fetchCurrencyNetworkMappings() {
    const response = await fetch('/api/currency-network-mappings');
    const result = await response.json();

    if (result.success && result.data) {
        // Store data globally
        currencyNetworkData.network_to_currencies = result.data.network_to_currencies;
        currencyNetworkData.currency_to_networks = result.data.currency_to_networks;

        // Extract unique lists
        currencyNetworkData.all_networks = Object.keys(...).sort();
        currencyNetworkData.all_currencies = Object.keys(...).sort();

        // Populate dropdowns
        populateNetworkDropdown();
        populateCurrencyDropdown();
    }
}

This function:
1. Fetches data from API endpoint
2. Stores it in global JavaScript object currencyNetworkData
3. Extracts sorted lists of all networks and all currencies
4. Calls functions to populate both dropdown menus


STEP 4: Dropdown Population (register.html)
--------------------------------------------
File: templates/register.html
Lines: 293-337

Two functions populate the dropdown menus:

populateNetworkDropdown() [Lines 294-313]
------------------------------------------
function populateNetworkDropdown(selectedNetwork = '') {
    const networkSelect = document.getElementById('client_payout_network');

    // Clear existing options
    networkSelect.innerHTML = '<option value="">-- Select Network --</option>';

    // Add all networks
    currencyNetworkData.all_networks.forEach(network => {
        const option = document.createElement('option');
        option.value = network;
        option.textContent = network;
        networkSelect.appendChild(option);
    });
}

Result: Dropdown shows ["-- Select Network --", "BNB", "BTC", "ETH", "MATIC", "SOL", "TRX", ...]

populateCurrencyDropdown() [Lines 316-337]
-------------------------------------------
function populateCurrencyDropdown(selectedCurrency = '') {
    const currencySelect = document.getElementById('client_payout_currency');

    // Clear existing options
    currencySelect.innerHTML = '<option value="">-- Select Currency --</option>';

    // Add all currencies
    currencyNetworkData.all_currencies.forEach(currency => {
        const option = document.createElement('option');
        option.value = currency;
        option.textContent = currency;
        currencySelect.appendChild(option);
    });
}

Result: Dropdown shows ["-- Select Currency --", "BTC", "ETH", "SOL", "USDC", "USDT", ...]


===============================================================================
üîÅ BIDIRECTIONAL FILTERING MECHANISM
===============================================================================

The dropdowns are NOT static. They dynamically filter based on user selections.

SCENARIO A: User Selects Network First
---------------------------------------
File: templates/register.html
Lines: 339-371

1. User selects "SOL" from Network Type dropdown
2. Event listener triggers: onNetworkChange() function
3. Function looks up: currencyNetworkData.network_to_currencies["SOL"]
4. Returns: ["USDT", "USDC", "SOL", ...]
5. Currency dropdown is repopulated with ONLY these currencies
6. Any previously selected currency is preserved if it's still valid

Example Flow:
Network Selection: "SOL"
‚Üì
Available Currencies: ["SOL", "USDC", "USDT", ...]
‚Üì
Currency Dropdown: Shows only currencies available on SOL network


SCENARIO B: User Selects Currency First
----------------------------------------
File: templates/register.html
Lines: 373-405

1. User selects "USDT" from Payout Currency dropdown
2. Event listener triggers: onCurrencyChange() function
3. Function looks up: currencyNetworkData.currency_to_networks["USDT"]
4. Returns: ["SOL", "ETH", "BNB", "MATIC", "TRX", ...]
5. Network dropdown is repopulated with ONLY these networks
6. Any previously selected network is preserved if it's still valid

Example Flow:
Currency Selection: "USDT"
‚Üì
Available Networks: ["BNB", "ETH", "MATIC", "SOL", "TRX", ...]
‚Üì
Network Dropdown: Shows only networks that support USDT


SCENARIO C: User Changes Selection
-----------------------------------
1. User selects "SOL" network ‚Üí Currency dropdown filters to SOL-compatible currencies
2. User selects "USDT" currency ‚Üí Network dropdown updates to show USDT-compatible networks
3. User changes network to "ETH" ‚Üí Currency dropdown updates to ETH-compatible currencies
4. Previously selected "USDT" remains selected (it exists on both SOL and ETH)


===============================================================================
‚úÖ FORM VALIDATION: validate_choice=False
===============================================================================

Critical Implementation Detail:
--------------------------------
File: forms.py
Lines: 211-239

Both SelectField definitions include:
    validate_choice=False

Why This Is Necessary:
----------------------
Flask-WTF's SelectField normally validates that submitted values exist in the
hardcoded choices list. Since our dropdowns are populated dynamically via
JavaScript AFTER the form loads, the choices list only contains placeholders:

    choices=[('', '-- Select Network --')]  # Only placeholder

When the user submits "SOL", Flask-WTF would normally reject it because "SOL"
is not in the static choices list.

Setting validate_choice=False tells Flask-WTF to:
‚úÖ Skip choice validation (allow any submitted value)
‚úÖ Still enforce DataRequired validation (reject empty submissions)

Security is maintained through:
1. JavaScript ensures only valid database pairs can be selected
2. Database INSERT will fail if values don't exist in currency_to_network table
3. ChangeNow API will reject invalid currency-network combinations


===============================================================================
üíæ DATA PERSISTENCE: SUBMISSION TO DATABASE
===============================================================================

After user submits the form:

File: app.py
Lines: 120-145

1. Form is validated (all fields checked)
2. CAPTCHA is verified
3. Data is extracted:
   registration_data = {
       ...
       'client_payout_currency': form.client_payout_currency.data.upper(),
       'client_payout_network': form.client_payout_network.data.upper()
   }

4. Data is inserted into main_clients_database table:
   INSERT INTO main_clients_database
   (..., client_payout_currency, client_payout_network)
   VALUES (..., 'USDT', 'SOL')

5. These values flow through the entire payment pipeline:
   main_clients_database
   ‚Üí TelePay (fetch from DB)
   ‚Üí Encrypted Token
   ‚Üí GCWebhook (decode from token)
   ‚Üí GCSplit (receive from webhook)
   ‚Üí ChangeNow API (use for transaction)
   ‚Üí split_payout_request & split_payout_que tables (store transaction details)


===============================================================================
üîç DEBUGGING & VERIFICATION
===============================================================================

To verify the dropdown population system is working:

1. Check Database Content:
   -----------------------
   SELECT COUNT(*) FROM currency_to_network;
   -- Should return: 196 (or however many mappings exist)

   SELECT currency, network FROM currency_to_network WHERE currency = 'USDT';
   -- Shows all networks that support USDT

2. Check API Endpoint:
   --------------------
   curl https://gcregister10-23-XXXXXXXXX-uc.a.run.app/api/currency-network-mappings

   Expected Response:
   {
       "success": true,
       "data": {
           "mappings": [...],
           "network_to_currencies": {...},
           "currency_to_networks": {...}
       }
   }

3. Check Browser Console:
   -----------------------
   Open browser DevTools (F12) ‚Üí Console tab

   Expected Logs:
   üîç Fetching currency-network mappings...
   ‚úÖ Loaded 10 networks and 50 currencies
   üìä Populated network dropdown with 10 networks
   üìä Populated currency dropdown with 50 currencies

4. Check Network Tab:
   -------------------
   Open browser DevTools (F12) ‚Üí Network tab

   Look for request to: /api/currency-network-mappings
   Status: 200 OK
   Response Type: application/json
   Response Size: ~5-10 KB (depending on number of mappings)

5. Inspect Dropdown HTML:
   -----------------------
   Right-click Network dropdown ‚Üí Inspect Element

   Expected HTML:
   <select class="form-select" id="client_payout_network" name="client_payout_network">
       <option value="">-- Select Network --</option>
       <option value="BNB">BNB</option>
       <option value="BTC">BTC</option>
       <option value="ETH">ETH</option>
       <option value="MATIC">MATIC</option>
       <option value="SOL">SOL</option>
       <option value="TRX">TRX</option>
       ...
   </select>


===============================================================================
üìä SUMMARY DIAGRAM
===============================================================================

PostgreSQL Database (currency_to_network table)
    ‚Üì
database_manager.py: get_currency_to_network_mappings()
    ‚Üì
app.py: GET /api/currency-network-mappings
    ‚Üì
register.html: fetch('/api/currency-network-mappings')
    ‚Üì
JavaScript: Store in currencyNetworkData object
    ‚Üì
JavaScript: populateNetworkDropdown() + populateCurrencyDropdown()
    ‚Üì
HTML Dropdowns: Display options to user
    ‚Üì
User Selection: Choose network & currency
    ‚Üì
JavaScript: Bidirectional filtering (onNetworkChange / onCurrencyChange)
    ‚Üì
Form Submission: POST to /register
    ‚Üì
app.py: Validate & extract data
    ‚Üì
database_manager.py: Insert into main_clients_database
    ‚Üì
Payment Pipeline: Flow through TelePay ‚Üí Token ‚Üí GCWebhook ‚Üí GCSplit ‚Üí ChangeNow


===============================================================================
üéØ KEY TAKEAWAYS
===============================================================================

1. Source of Truth:
   The `currency_to_network` table in PostgreSQL is the single source of truth
   for all valid currency-network combinations.

2. Dynamic Population:
   Dropdowns are populated via JavaScript fetching from an API endpoint, NOT
   hardcoded in the HTML template.

3. Bidirectional Filtering:
   Selecting either Network or Currency dynamically filters the other dropdown
   to show only valid combinations.

4. Database-Driven:
   All dropdown options come from the database, making it easy to add/remove
   supported currency-network pairs without code changes.

5. Validation:
   Form validation uses validate_choice=False to allow dynamic values while
   maintaining security through JavaScript filtering and database constraints.

6. Data Flow:
   Selected values flow through the entire payment pipeline from registration
   to ChangeNow API transaction creation.


===============================================================================
üìÅ RELATED FILES
===============================================================================

1. database_manager.py (Lines 226-284)
   - get_currency_to_network_mappings() method
   - Queries currency_to_network table
   - Builds bidirectional lookup dictionaries

2. app.py (Lines 205-244)
   - /api/currency-network-mappings endpoint
   - Returns JSON data for JavaScript consumption

3. templates/register.html (Lines 256-468)
   - JavaScript fetch function
   - Dropdown population functions
   - Bidirectional filtering event handlers

4. forms.py (Lines 211-239)
   - SelectField definitions with validate_choice=False
   - Placeholder choices for initial render

5. database_manager.py (Lines 131-204)
   - insert_channel_registration() method
   - Inserts selected network & currency into main_clients_database


===============================================================================
