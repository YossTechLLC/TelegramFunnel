# Bug Tracker - TelegramFunnel OCTOBER/10-26

**Last Updated:** 2025-11-09 Session 101

---

## Active Bugs

### üêõ Documentation: Invalid Example EVM Address (Low Priority)

**Date Discovered:** 2025-11-08 Session 83
**File:** WALLET_ADDRESS_VALIDATION_ANALYSIS.md
**Severity:** LOW - Documentation only, no production impact
**Status:** üîç **DOCUMENTED - NOT URGENT**

**Issue:**
Example EVM address used throughout documentation has only 39 hex characters instead of required 40.

**Invalid Address:**
```
0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb  ‚Üê Only 39 hex chars (should be 40)
```

**Locations:**
- Line 43: Input placeholder example
- Line 56: Address format explanation
- Line 788: Test addresses object
- Line 847: User scenario example

**Expected Format:**
- EVM addresses: `0x` + exactly 40 hexadecimal characters
- Total length: 42 characters
- Example of valid address: `0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb0` (added one char)

**Impact:**
- ‚úÖ Production code unaffected - validation working correctly
- ‚úÖ Rejects invalid addresses as expected
- ‚ö†Ô∏è Documentation examples misleading (shows invalid address as example)
- ‚ö†Ô∏è Could confuse developers reading the docs

**Fix Required:**
Replace all instances with valid 40-hex-char EVM address like:
`0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb0`

**Priority:** Low - Can be fixed during next documentation update

---

## Recently Resolved

### ‚úÖ RESOLVED: Signup Validation Error Causes 500 Internal Server Error (CRITICAL)

**Date Discovered:** 2025-11-09 Session 101
**Date Resolved:** 2025-11-09 Session 101 (same session)
**Service:** GCRegisterAPI-10-26
**Severity:** CRITICAL - Production signup completely broken for users with weak passwords
**Status:** ‚úÖ **RESOLVED**

**User Report:**
User attempted to create account with credentials:
- Username: `slickjunt`
- Email: `slickjunt@gmail.com`
- Password: `herpderp123`

Result: "Internal server error" displayed on signup page

**Root Causes Identified:**

**1. Password Validation Failure (Expected Behavior):**
- Password `herpderp123` failed validation requirements
- Missing required uppercase letter (all lowercase)
- Pydantic validator in `SignupRequest` model correctly raised `ValueError`
- File: `api/models/auth.py` lines 27-39

**2. JSON Serialization Bug in Error Handler (Actual Bug):**
- ValidationError handler attempted to return `e.errors()` directly in JSON response
- Pydantic's `ValidationError.errors()` contains non-serializable Python exception objects
- Flask's `jsonify()` crashed with: `TypeError: Object of type ValueError is not JSON serializable`
- This converted a proper 400 validation error into a 500 server error
- File: `api/routes/auth.py` lines 108-125

**Error Flow:**
1. User submits password without uppercase letter
2. Line 55: `SignupRequest(**request.json)` raises `ValidationError`
3. Line 108: Caught by `except ValidationError as e:` handler
4. Line 121-125: Handler tries to jsonify `e.errors()` containing ValueError objects
5. Flask JSON encoder crashes ‚Üí Returns 500 instead of 400

**Cloud Logging Evidence:**
```
Traceback (most recent call last):
  File "/usr/local/lib/python3.11/site-packages/flask/json/provider.py", line 120, in _default
    raise TypeError(f"Object of type {type(o).__name__} is not JSON serializable")
TypeError: Object of type ValueError is not JSON serializable
```

**Resolution:**

**File Modified:** `api/routes/auth.py` lines 108-134

**Before (Broken):**
```python
except ValidationError as e:
    print(f"‚ùå Signup validation error: {e.errors()}")
    # ... audit logging ...
    return jsonify({
        'success': False,
        'error': 'Validation failed',
        'details': e.errors()  # ‚Üê CRASHES: Contains ValueError objects
    }), 400
```

**After (Fixed):**
```python
except ValidationError as e:
    print(f"‚ùå Signup validation error: {e.errors()}")
    # ... audit logging ...

    # Convert validation errors to JSON-safe format
    error_details = []
    for error in e.errors():
        error_details.append({
            'field': '.'.join(str(loc) for loc in error['loc']),
            'message': error['msg'],
            'type': error['type']
        })

    return jsonify({
        'success': False,
        'error': 'Validation failed',
        'details': error_details  # ‚Üê SAFE: Pure dict/str/int types
    }), 400
```

**Deployment:**
- Build ID: Auto-generated by Cloud Build
- Revision: `gcregisterapi-10-26-00022-d2n`
- Deployed: 2025-11-09 Session 101
- Service URL: https://gcregisterapi-10-26-pjxwjsdktq-uc.a.run.app

**Testing Performed:**

**Test 1: Invalid Password (No Uppercase)**
```bash
# Input: username=slickjunt, email=slickjunt@gmail.com, password=herpderp123
# Expected: 400 Bad Request with validation error message
# Result: ‚úÖ Returns 400 with "Validation failed" message
# Frontend displays: "Validation failed" (not "Internal server error")
```

**Test 2: Valid Password (With Uppercase)**
```bash
# Input: username=slickjunt2, email=slickjunt2@gmail.com, password=Herpderp123
# Expected: 201 Created, account created, auto-login
# Result: ‚úÖ Account created successfully
# Redirected to dashboard with "Please Verify E-Mail" button
```

**Impact:**
- ‚úÖ Signup errors now return proper 400 status codes (not 500)
- ‚úÖ Users receive clear validation error messages
- ‚úÖ Frontend can display specific field errors
- ‚úÖ Server no longer crashes on validation failures
- ‚úÖ Audit logging still works correctly
- ‚úÖ Password validation requirements enforced properly

**Password Requirements:**
- Minimum 8 characters
- At least one uppercase letter (A-Z)
- At least one lowercase letter (a-z)
- At least one digit (0-9)

**Files Changed:**
1. `GCRegisterAPI-10-26/api/routes/auth.py` (lines 121-128 added)

**Lessons Learned:**
- Always serialize exception objects to strings before JSON encoding
- Test error handlers with actual failing inputs
- Pydantic validation errors need special handling for JSON responses
- 500 errors mask underlying validation issues - always return appropriate status codes

---

### üîí Database: Missing UNIQUE Constraints + Duplicate User Accounts (CRITICAL)

**Date Discovered:** 2025-11-09 Session 91
**Date Resolved:** 2025-11-09 Session 91
**Severity:** CRITICAL - Login completely broken for affected users
**Status:** ‚úÖ **RESOLVED**

**User Report:**
- Cannot login with user1 (user1TEST$) or user2 (user2TEST$)
- Verification link clicked successfully showing "Email already verified"
- Login fails with error: "Invalid username or password"

**Root Cause:**
1. **Missing UNIQUE Constraints**: Database table `registered_users` had no UNIQUE constraints on username or email columns
2. **Duplicate Accounts Created**: user2 was registered TWICE:
   - First: 2025-11-09 13:55:15 (revision 00015-hrc) with password hash A
   - Second: 2025-11-09 14:09:16 (revision 00016-kds) with password hash B
3. **Password Mismatch**: User tried to login with password from first registration, but database had second registration with different hash
4. **Application-Level Only**: Duplicate checks existed in `auth_service.py` but no database-level enforcement

**Investigation Timeline:**
1. Used Playwright to test login ‚Üí Captured 401 Unauthorized errors
2. Analyzed Cloud Logging ‚Üí Found "Invalid username or password" in audit logs
3. Tested API directly with curl ‚Üí Confirmed backend returning 401
4. Reviewed auth_service.py ‚Üí Authentication logic correct (lines 135-198)
5. Checked database records ‚Üí Discovered multiple user2 entries with different created_at timestamps

**Technical Analysis:**
```sql
-- BEFORE FIX: This query would return multiple rows
SELECT username, COUNT(*) as count, array_agg(user_id ORDER BY created_at)
FROM registered_users
GROUP BY username
HAVING COUNT(*) > 1;

-- user2 appeared twice with different user_ids and password_hashes
```

**Resolution:**

**1. Created Migration Script:**
- File: `database/migrations/fix_duplicate_users_add_unique_constraints.sql`
- Deleted duplicate username records (kept most recent by created_at DESC)
- Deleted duplicate email records (kept most recent by created_at DESC)
- Added UNIQUE constraint on username column
- Added UNIQUE constraint on email column

**2. Created Migration Executor:**
- File: `run_migration.py`
- Uses application's DatabaseManager for connection
- Executes migration with transaction safety
- Reports deleted records and constraint additions
- Verifies constraints after migration

**3. Migration Execution:**
```bash
python3 run_migration.py
```

**Migration Results:**
- Deleted: 0 duplicate username records (already cleaned up)
- Deleted: 0 duplicate email records (already cleaned up)
- Added: UNIQUE constraint "unique_username" on username column
- Added: UNIQUE constraint "unique_email" on email column
- Database now has 4 total UNIQUE constraints

**Files Changed:**
1. `database/migrations/fix_duplicate_users_add_unique_constraints.sql` - NEW FILE (comprehensive migration)
2. `run_migration.py` - NEW FILE (migration executor script)

**Current State:**
- ‚úÖ Database has UNIQUE constraints on username and email
- ‚úÖ Duplicate registration now IMPOSSIBLE at database level
- ‚úÖ Application-level checks backed by DB constraints
- ‚úÖ user2 account verified and exists (created 14:09:16)
- ‚ö†Ô∏è user2 password hash is from SECOND registration (not first)

**User Impact:**
- **user2**: Account exists and verified, but password is from second registration (may need reset)
- **user1**: Should work with original password (if remembered)
- **Future users**: Protected from duplicate account issues

**Testing Performed:**
```bash
# Test duplicate username - BLOCKED
curl -X POST /api/auth/signup \
  -d '{"username":"user2","email":"new@test.com","password":"Test1234$"}'
# Response: {"error":"Username already exists","success":false}

# Test duplicate email - BLOCKED
curl -X POST /api/auth/signup \
  -d '{"username":"newuser","email":"user4test@test.com","password":"Test1234$"}'
# Response: {"error":"Email already exists","success":false}

# Test new registration - WORKS
curl -X POST /api/auth/signup \
  -d '{"username":"user4","email":"user4test@test.com","password":"user4TEST$"}'
# Response: {"success":true,"verification_required":true,...}
```

**Prevention Measures:**
1. ‚úÖ UNIQUE constraints enforce uniqueness at database level
2. ‚úÖ PostgreSQL will reject INSERT/UPDATE that violates constraints
3. ‚úÖ Application code already handles constraint violations gracefully
4. ‚úÖ Constraint violations return proper error messages to users

**Lessons Learned:**
- Always add UNIQUE constraints for fields that must be unique
- Database constraints provide critical safety net beyond application-level checks
- Test duplicate scenarios thoroughly before production
- Monitor for duplicate data patterns in logs

### ‚úÖ Email Verification Link Not Working (CRITICAL - RESOLVED)

**Date Discovered:** 2025-11-09 Session 90
**Date Resolved:** 2025-11-09 Session 90
**Severity:** CRITICAL - Production functionality broken
**Status:** ‚úÖ **RESOLVED**

**User Report:**
User 'user2' registered but couldn't verify email. Verification link had space in URL and clicking it caused sign out with error "Email not verified. Please check your email for the verification link."

**Root Causes Identified:**
1. **URL Whitespace Bug**: CORS_ORIGIN secret in Secret Manager had trailing newline character, causing URLs like `https://www.paygateprime.com /verify-email?token=...` (space after .com)
2. **Missing Frontend Routes**: No `/verify-email` or `/reset-password` routes in React app - links went to 404
3. **Missing AuthService Methods**: No `verifyEmail()` or `resetPassword()` methods to call backend API

**Fixes Applied:**

**Backend (GCRegisterAPI-10-26):**
- Fixed `config_manager.py` line 30: Added `.strip()` to remove whitespace from all secrets
- Deployed revision `gcregisterapi-10-26-00016-kds`

**Frontend (GCRegisterWeb-10-26):**
- Created `VerifyEmailPage.tsx` - Handles `/verify-email?token=...` route
- Created `ResetPasswordPage.tsx` - Handles `/reset-password?token=...` route
- Updated `authService.ts` - Added 4 methods: `verifyEmail()`, `resendVerification()`, `requestPasswordReset()`, `resetPassword()`
- Updated `App.tsx` - Added 2 routes: `/verify-email` and `/reset-password`
- Deployed to `gs://www-paygateprime-com/` with CDN cache invalidation

**Testing:**
- Verification links now have clean URLs (no spaces)
- `/verify-email` route loads properly
- Backend API verification works correctly
- User can successfully verify email and login

**Impact:**
- ‚úÖ Email verification now fully functional
- ‚úÖ Password reset flow complete
- ‚úÖ User 'user2' (and all future users) can verify emails

**Prevention:**
- All secrets now stripped of whitespace automatically
- Frontend routes complete for all auth flows
- Comprehensive error handling in place

---

### ‚úÖ RESOLVED: Wallet Address Paste Duplication

**Date Discovered:** 2025-11-08 Session 84
**Date Resolved:** 2025-11-08 Session 84 (same session)
**Component:** GCRegisterWeb-10-26 (RegisterChannelPage & EditChannelPage)
**Severity:** MEDIUM - UX Issue (affects all users pasting wallet addresses)
**Status:** ‚úÖ **FIXED - DEPLOYED TO PRODUCTION**

**Issue:**
When users copy/pasted a wallet address into the "Your Wallet Address" field, the value appeared twice (duplicated).

**Example:**
- User copies: `EQD2NmD_lH5f5u1Kj3KfGyTvhZSX0Eg6qp2a5IQUKXxrJcvP`
- After paste: `EQD2NmD_lH5f5u1Kj3KfGyTvhZSX0Eg6qp2a5IQUKXxrJcvPEQD2NmD_lH5f5u1Kj3KfGyTvhZSX0Eg6qp2a5IQUKXxrJcvP`

**Root Cause:**
The `onPaste` event handler was calling `setClientWalletAddress(pastedText)` but NOT preventing the browser's default paste behavior. This resulted in:
1. Custom handler setting the state with pasted text
2. Browser's default paste also inserting the text
3. Value appearing twice in the input field

**Code Location:**
- `RegisterChannelPage.tsx` lines 668-672
- `EditChannelPage.tsx` lines 734-738

**Fix:**
Added `e.preventDefault()` at the start of both onPaste handlers:

```typescript
onPaste={(e) => {
  e.preventDefault();  // ‚Üê ADDED THIS LINE
  const pastedText = e.clipboardData.getData('text');
  setClientWalletAddress(pastedText);
  debouncedDetection(pastedText);
}}
```

**Testing:**
- ‚úÖ Tested on production with TON address
- ‚úÖ Single paste (no duplication)
- ‚úÖ Validation still working correctly
- ‚úÖ Network auto-detection functional

**Deployment:**
- Build: `index-BFZtVN_a.js` (311.87 kB)
- Deployed: 2025-11-08 Session 84
- Production URL: https://www.paygateprime.com/register

**Impact:**
- All users pasting wallet addresses now get correct behavior
- No breaking changes
- Validation system unaffected

---

### ‚úÖ RESOLVED: GCSplit1 Endpoint_2 Dictionary Key Naming Mismatch

**Date Discovered:** 2025-11-07 Session 67
**Date Resolved:** 2025-11-07 Session 67 (same day)
**Service:** GCSplit1-10-26 (endpoint_2 code)
**Severity:** CRITICAL - BLOCKING PRODUCTION (instant AND threshold payouts)
**Status:** ‚úÖ **FIXED - DEPLOYED TO PRODUCTION**

**Context:**
After fixing token decryption field ordering (Session 66), discovered that endpoint_2 code was trying to access wrong dictionary key, causing KeyError that blocked both instant and threshold payment flows.

**Error Evidence:**
```
2025-11-07 11:18:36.849 EST
‚úÖ [TOKEN_DEC] Estimate response decrypted successfully  ‚Üê Token decryption WORKS
üéØ [TOKEN_DEC] Payout Mode: instant, Swap Currency: eth  ‚Üê Fields extracted correctly
üí∞ [TOKEN_DEC] ACTUAL ETH extracted: 0.0010582  ‚Üê All data present
‚ùå [ENDPOINT_2] Unexpected error: 'to_amount_eth_post_fee'  ‚Üê KeyError
```

**Root Cause:**
**Dictionary key naming inconsistency**:
- GCSplit1 decrypt method returns: `"to_amount_post_fee"` (generic dual-currency name) ‚úÖ
- GCSplit1 endpoint_2 code expected: `"to_amount_eth_post_fee"` (legacy ETH-only name) ‚ùå
- Result: KeyError on line 476 when accessing non-existent dictionary key

**Why It Happened:**
- Token decrypt method was updated for dual-currency support (generic naming)
- Endpoint code still used legacy ETH-specific naming from single-currency era
- No cross-reference check between decrypt method and endpoint code

**Fix Applied:**
- Updated `calculate_pure_market_conversion()` function signature (lines 199-204)
- Updated all internal variable names (lines 226-255)
- **CRITICAL:** Fixed dictionary key access on line 476: `to_amount_post_fee = decrypted_data['to_amount_post_fee']`
- Updated print statement (line 487)
- Updated function call (line 492)

**Total Changes:** 10 lines modified in `/GCSplit1-10-26/tps1-10-26.py`

**Deployment:**
- Build: 3de64cbd-98ad-41de-a515-08854d30039e (44s)
- Image: gcr.io/telepay-459221/gcsplit1-10-26:endpoint2-keyerror-fix
- Revision: gcsplit1-10-26-00020-rnq
- Time: 2025-11-07 16:33 UTC
- Health: All systems operational

**Impact:**
- ‚úÖ Both instant (ETH) and threshold (USDT) payouts now unblocked
- ‚úÖ No changes needed to GCSplit2 or GCSplit3
- ‚úÖ Maintains dual-currency architecture naming consistency
- ‚úÖ System ready for end-to-end testing

**Lesson Learned:**
When updating data structures (token fields), verify ALL code paths that access those structures, not just the serialization/deserialization methods.

**Documentation:**
- `/10-26/GCSPLIT1_ENDPOINT_2_CHECKLIST.md` (original issue analysis)
- `/10-26/GCSPLIT1_ENDPOINT_2_CHECKLIST_PROGRESS.md` (fix implementation tracker)

---

### ‚úÖ RESOLVED: GCSplit1 Token Decryption Field Ordering Mismatch

**Date Discovered:** 2025-11-07 Session 66
**Date Resolved:** 2025-11-07 Session 66 (same day)
**Service:** GCSplit1-10-26 (affects GCSplit2 token decryption)
**Severity:** CRITICAL - BLOCKING PRODUCTION (instant AND threshold payouts)
**Status:** ‚úÖ **FIXED - DEPLOYED TO PRODUCTION**

**Context:**
Dual-currency implementation (instant payouts via ETH, threshold payouts via USDT) is completely blocked due to token field ordering mismatch between GCSplit2's encryption and GCSplit1's decryption.

**Error Log Evidence:**
```
2025-11-07 10:40:46.084 EST
üîì [TOKEN_DEC] GCSplit2‚ÜíGCSplit1: Decrypting estimate response
‚ö†Ô∏è [TOKEN_DEC] No swap_currency in token (backward compat - defaulting to 'usdt')
‚ö†Ô∏è [TOKEN_DEC] No payout_mode in token (backward compat - defaulting to 'instant')
üí∞ [TOKEN_DEC] ACTUAL ETH extracted: 2.6874284797920923e-292  ‚ùå CORRUPTED
‚ùå [TOKEN_DEC] Decryption error: Token expired
‚ùå [ENDPOINT_2] Failed to decrypt token
‚ùå [ENDPOINT_2] Unexpected error: 401 Unauthorized: Invalid token
```

**Root Cause:**
**Binary struct unpacking order mismatch** between GCSplit2's packing and GCSplit1's unpacking:
