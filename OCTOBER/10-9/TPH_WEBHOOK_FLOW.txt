================================================================================
TPH7-14 WEBHOOK FLOW ANALYSIS
OCTOBER/10-9 - Complete Payment Success Webhook Documentation
================================================================================

This document provides a comprehensive analysis of how the tph7-14.py webhook
is triggered, what payload is sent, and where that payload is generated.

================================================================================
ğŸ¯ EXECUTIVE SUMMARY
================================================================================

WEBHOOK PURPOSE:
The tph7-14.py webhook (GCWebhook7-14) is NOT a traditional webhook that
receives POST requests with JSON payloads. Instead, it is a GET endpoint that
receives payment success redirects from NowPayments with a cryptographically
signed token in the URL query string.

TRIGGER METHOD:
  - User completes payment on NowPayments
  - NowPayments redirects user's browser to the success URL
  - Success URL contains an encoded token with all payment/user data
  - Token is generated by TelePay7-14 BEFORE payment begins

PAYLOAD TYPE: URL Query Parameter (NOT JSON)
  - Parameter name: "token"
  - Format: Base64-encoded binary data with HMAC signature
  - Transport: HTTP GET request (browser redirect)

KEY INSIGHT:
The "payload" is NOT sent TO the webhookâ€”it's embedded IN the webhook URL
when the payment invoice is first created. NowPayments simply redirects to
this pre-signed URL after successful payment.

================================================================================
ğŸ“Š COMPLETE FLOW DIAGRAM
================================================================================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 1: User Initiates Payment                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  User clicks subscription button in Telegram bot
  â†“
  TelePay7-14/menu_handlers.py handles callback
  â†“
  Calls payment_gateway_wrapper()
  â†“
  Routes to PaymentGatewayManager.start_np_gateway_new()

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 2: Gather Payment Data (TelePay7-14)                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  File: TelePay7-14/start_np_gateway.py
  Function: start_np_gateway_new() [Lines 175-243]

  Data Collected:
    âœ“ user_id: From Telegram update
    âœ“ global_open_channel_id: From subscription token
    âœ“ global_sub_value: Subscription price (e.g., 15.00)
    âœ“ global_sub_time: Subscription duration in days (e.g., 30)

  Database Lookups:
    âœ“ closed_channel_id: Fetched from database via db_manager
    âœ“ client_wallet_address: Fetched from database
    âœ“ client_payout_currency: Fetched from database
    âœ“ closed_channel_title: Fetched from database
    âœ“ closed_channel_description: Fetched from database

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 3: Generate Signed Success URL (TelePay7-14)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  File: TelePay7-14/start_np_gateway.py [Lines 224-231]

  Code:
  ```python
  secure_success_url = webhook_manager.build_signed_success_url(
      user_id=user_id,
      closed_channel_id=closed_channel_id,
      client_wallet_address=wallet_address or "",
      client_payout_currency=payout_currency or "",
      subscription_time=global_sub_time,
      subscription_price=str(global_sub_value)
  )
  ```

  â†“ Calls â†’

  File: TelePay7-14/secure_webhook.py
  Function: build_signed_success_url() [Lines 58-154]

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 4: Token Generation Process (TelePay7-14)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  File: TelePay7-14/secure_webhook.py
  Function: build_signed_success_url()

  INPUT PARAMETERS:
    - user_id: int (Telegram user ID)
    - closed_channel_id: int (Premium channel ID)
    - client_wallet_address: str (Max 110 chars)
    - client_payout_currency: str (Max 4 chars)
    - subscription_time: int (1-999 days)
    - subscription_price: str (e.g., "15.00", max 6 chars)

  ENCODING PROCESS:

  Step 4.1: Convert IDs to 48-bit integers
    user_id_bytes = user_id.to_bytes(6, 'big')           # 6 bytes
    channel_id_bytes = closed_channel_id.to_bytes(6, 'big')  # 6 bytes

  Step 4.2: Pack timestamp
    timestamp_minutes = int(time.time() // 60) % 65536   # 2 bytes
    # Uses 16-bit value with ~45 day wrap-around cycle

  Step 4.3: Encode strings to UTF-8 bytes
    wallet_bytes = wallet_address.encode('utf-8')        # Variable length
    currency_bytes = payout_currency.encode('utf-8')     # Variable length
    price_bytes = subscription_price.encode('utf-8')     # Variable length

  Step 4.4: Build packed binary structure
    packed = (
        user_id_bytes                        # 6 bytes: User ID
        + channel_id_bytes                   # 6 bytes: Channel ID
        + struct.pack(">H", timestamp_minutes)  # 2 bytes: Timestamp
        + struct.pack(">H", subscription_time)  # 2 bytes: Sub duration
        + struct.pack(">B", len(price_bytes))   # 1 byte: Price length
        + price_bytes                           # N bytes: Price string
        + struct.pack(">B", len(wallet_bytes))  # 1 byte: Wallet length
        + wallet_bytes                          # M bytes: Wallet address
        + struct.pack(">B", len(currency_bytes)) # 1 byte: Currency length
        + currency_bytes                        # P bytes: Currency code
    )

  Step 4.5: Create HMAC signature
    full_signature = hmac.new(
        signing_key.encode(),
        packed,
        hashlib.sha256
    ).digest()                               # 32 bytes full signature
    signature = full_signature[:16]          # 16 bytes truncated

  Step 4.6: Combine data and signature
    payload = packed + signature

  Step 4.7: Base64 encode
    token = base64.urlsafe_b64encode(payload).decode().rstrip("=")

  Step 4.8: Build final URL
    success_url = f"{base_url}?token={token}"
    # Example: https://webhook.example.com?token=ABC123XYZ...

  BINARY STRUCTURE DIAGRAM:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ User ID â”‚ Chan ID  â”‚ Timestamp â”‚ Sub Time â”‚ Variable-Length Data       â”‚
  â”‚ 6 bytes â”‚ 6 bytes  â”‚ 2 bytes   â”‚ 2 bytes  â”‚ Price + Wallet + Currency  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              Signed with HMAC-SHA256
                              (16-byte truncated signature appended)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 5: Create NowPayments Invoice (TelePay7-14)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  File: TelePay7-14/start_np_gateway.py
  Function: start_payment_flow() [Lines 106-173]
  Then calls: create_payment_invoice() [Lines 33-88]

  NowPayments API Request:
    POST https://api.nowpayments.io/v1/invoice
    Headers:
      x-api-key: <NOWPAYMENTS_API_KEY>
      Content-Type: application/json

    Body:
    {
        "price_amount": 15.00,              // Subscription price
        "price_currency": "USD",
        "order_id": "PGP-123456-1001234567890",  // User ID + Channel ID
        "order_description": "Payment-Test-1",
        "success_url": "https://webhook.example.com?token=ABC123...",  // â† OUR SIGNED URL
        "is_fixed_rate": false,
        "is_fee_paid_by_user": false
    }

    Response (if successful):
    {
        "invoice_url": "https://nowpayments.io/payment/...",  // User goes here
        "id": "123456",
        "order_id": "PGP-123456-1001234567890",
        // ... other fields ...
    }

  â­ KEY POINT: The "success_url" field contains our signed token!

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 6: User Completes Payment (External: NowPayments)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  User is directed to NowPayments invoice page
  â†“
  User selects cryptocurrency and completes payment
  â†“
  NowPayments confirms payment received
  â†“
  NowPayments redirects user's browser:
    GET https://webhook.example.com?token=ABC123...

  â­ KEY POINT: This is a BROWSER REDIRECT, not a webhook POST!

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 7: Webhook Receives Request (GCWebhook7-14)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  File: GCWebhook7-14/tph7-14.py
  Flask Route: @app.route("/", methods=["GET"])
  Function: send_invite() [Lines 500-615]

  Request Details:
    Method: GET (not POST!)
    URL: https://webhook.example.com?token=ABC123XYZ...
    Parameters:
      - token: Base64-encoded signed payload
    Headers: Standard browser headers (not webhook-specific)

  Code Flow:

  Line 503: Extract token from URL
    token = request.args.get("token")

  Lines 508-509: Fetch credentials
    bot_token = fetch_telegram_bot_token()
    signing_key = fetch_success_url_signing_key()

  Line 523: Decode and verify token
    user_id, closed_channel_id, wallet_address, payout_currency,
    subscription_time_days, subscription_price = decode_and_verify_token(token, signing_key)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 8: Token Decoding Process (GCWebhook7-14)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  File: GCWebhook7-14/tph7-14.py
  Function: decode_and_verify_token() [Lines 82-201]

  DECODING PROCESS:

  Step 8.1: Base64 decode
    padding = '=' * (-len(token) % 4)
    raw = base64.urlsafe_b64decode(token + padding)

  Step 8.2: Parse fixed fields
    user_id = int.from_bytes(raw[0:6], 'big')              # Bytes 0-5
    closed_channel_id = int.from_bytes(raw[6:12], 'big')   # Bytes 6-11
    timestamp_minutes = struct.unpack(">H", raw[12:14])[0] # Bytes 12-13
    subscription_time_days = struct.unpack(">H", raw[14:16])[0]  # Bytes 14-15

  Step 8.3: Parse variable-length subscription price
    offset = 16
    price_len = struct.unpack(">B", raw[offset:offset+1])[0]
    offset += 1
    subscription_price = raw[offset:offset+price_len].decode('utf-8')
    offset += price_len

  Step 8.4: Parse variable-length wallet address
    wallet_len = struct.unpack(">B", raw[offset:offset+1])[0]
    offset += 1
    wallet_address = raw[offset:offset+wallet_len].decode('utf-8')
    offset += wallet_len

  Step 8.5: Parse variable-length currency
    currency_len = struct.unpack(">B", raw[offset:offset+1])[0]
    offset += 1
    payout_currency = raw[offset:offset+currency_len].decode('utf-8')
    offset += currency_len

  Step 8.6: Extract signature
    data = raw[:offset]     # All data fields
    sig = raw[offset:]      # Last 16 bytes

  Step 8.7: Verify HMAC signature
    expected_full_sig = hmac.new(signing_key.encode(), data, hashlib.sha256).digest()
    expected_sig = expected_full_sig[:16]
    if not hmac.compare_digest(sig, expected_sig):
        raise ValueError("Signature mismatch")

  Step 8.8: Handle negative Telegram IDs (48-bit wraparound)
    if user_id > 2**47 - 1:
        user_id -= 2**48
    if closed_channel_id > 2**47 - 1:
        closed_channel_id -= 2**48

  Step 8.9: Reconstruct timestamp and validate
    # Convert minutes back to Unix timestamp
    # Validate token is not expired (2-hour window)
    now = int(time.time())
    if not (now - 7200 <= timestamp <= now + 300):
        raise ValueError("Token expired or not yet valid")

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 9: Process Payment Success (GCWebhook7-14)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  File: GCWebhook7-14/tph7-14.py
  Function: send_invite() [Lines 534-615]

  EXTRACTED DATA FROM TOKEN:
    âœ“ user_id: 123456
    âœ“ closed_channel_id: -1001234567890
    âœ“ wallet_address: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb"
    âœ“ payout_currency: "ETH"
    âœ“ subscription_time_days: 30 (actually minutes for testing)
    âœ“ subscription_price: "15.00"

  Step 9.1: Calculate expiration [Line 534]
    expire_time, expire_date = calculate_expiration_time(subscription_time_days)
    # Currently uses MINUTES for testing (will be days in production)

  Step 9.2: Record subscription in database [Lines 543-551]
    record_private_channel_user(
        user_id=user_id,
        private_channel_id=closed_channel_id,
        sub_time=subscription_time_days,
        sub_price=subscription_price,
        expire_time=expire_time,
        expire_date=expire_date,
        is_active=True
    )

    Database Table: private_channel_users_database
    Columns Updated:
      - user_id
      - private_channel_id
      - sub_time (minutes for testing)
      - sub_price
      - timestamp (current time)
      - datestamp (current date)
      - expire_time (HH:MM:SS)
      - expire_date (YYYY-MM-DD)
      - is_active (true)

  Step 9.3: Send Telegram invite link [Lines 565-582]
    bot.create_chat_invite_link(
        chat_id=closed_channel_id,
        expire_date=int(time.time()) + 3600,  # 1 hour expiry
        member_limit=1                         # Single use
    )

    bot.send_message(
        chat_id=user_id,
        text="âœ… You've been granted access!\nHere is your one-time invite link:\n{link}"
    )

  Step 9.4: Trigger payment splitting webhook [Lines 587-592]
    trigger_payment_split_webhook(
        user_id=user_id,
        wallet_address=wallet_address,
        payout_currency=payout_currency,
        subscription_price=subscription_price
    )
    # Sends POST to GCSplit7-14/tps10-9.py for cryptocurrency conversion

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 10: Return Response to Browser (GCWebhook7-14)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  File: GCWebhook7-14/tph7-14.py [Line 615]

  HTTP Response:
    Status: 200 OK
    Body: {"status": "ok"}
    Content-Type: application/json

  User's browser receives this response
  (User has already received Telegram message with invite link)

================================================================================
ğŸ“¦ PAYLOAD STRUCTURE DETAILED BREAKDOWN
================================================================================

IMPORTANT: The "payload" is NOT a traditional webhook JSON body. Instead, it's
a binary-encoded token embedded in a URL query parameter.

FORMAT: Base64-encoded binary data

BEFORE ENCODING (Binary Structure):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Offset â”‚ Length â”‚ Field                    â”‚ Type      â”‚ Example      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0      â”‚ 6      â”‚ user_id                  â”‚ 48-bit BE â”‚ 123456       â”‚
â”‚ 6      â”‚ 6      â”‚ closed_channel_id        â”‚ 48-bit BE â”‚ -1001234567  â”‚
â”‚ 12     â”‚ 2      â”‚ timestamp_minutes        â”‚ 16-bit BE â”‚ 28945        â”‚
â”‚ 14     â”‚ 2      â”‚ subscription_time        â”‚ 16-bit BE â”‚ 30           â”‚
â”‚ 16     â”‚ 1      â”‚ price_length             â”‚ 8-bit     â”‚ 5            â”‚
â”‚ 17     â”‚ N      â”‚ subscription_price       â”‚ UTF-8     â”‚ "15.00"      â”‚
â”‚ 17+N   â”‚ 1      â”‚ wallet_length            â”‚ 8-bit     â”‚ 42           â”‚
â”‚ 18+N   â”‚ M      â”‚ wallet_address           â”‚ UTF-8     â”‚ "0x742d..."  â”‚
â”‚ 18+N+M â”‚ 1      â”‚ currency_length          â”‚ 8-bit     â”‚ 3            â”‚
â”‚ 19+N+M â”‚ P      â”‚ payout_currency          â”‚ UTF-8     â”‚ "ETH"        â”‚
â”‚ 19+N+M+Pâ”‚ 16    â”‚ HMAC signature (trunc)   â”‚ Binary    â”‚ <16 bytes>   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Total Size: 35+ bytes minimum (depending on string lengths)
  - Fixed: 19 bytes (IDs, timestamp, sub_time, length fields)
  - Variable: Price string (1-6 bytes)
  - Variable: Wallet address (0-110 bytes)
  - Variable: Currency code (0-4 bytes)
  - Signature: 16 bytes (truncated HMAC-SHA256)

AFTER BASE64 ENCODING:
  Example: "AAAAAAEePlIAbOwAu9YAAACUBTQ1LjAwKjB4NzQyZDM1Q2M2NjM0QzA1MzI5MjVhM2I4NDRCYzllNzU5NWYwYkViA0VUSJq8nKxz4pYmRd3vPQ2Bw8s="

  Characteristics:
    - URL-safe Base64 (uses - and _ instead of + and /)
    - Padding = characters stripped
    - Length: ~50-150 characters (depends on wallet address length)

EXAMPLE DECODED VALUES:
  user_id: 123456
  closed_channel_id: -1001234567890
  timestamp_minutes: 28945 (reconstructed to full Unix timestamp)
  subscription_time: 30 (days, but used as minutes in testing)
  subscription_price: "15.00"
  wallet_address: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb"
  payout_currency: "ETH"
  signature: <16 bytes of HMAC-SHA256>

================================================================================
ğŸ” SECURITY MECHANISMS
================================================================================

PROTECTION #1: HMAC-SHA256 Signature
  - Prevents tampering with any field (user_id, price, wallet, etc.)
  - Uses SECRET_URL_SIGNING_KEY shared between services
  - Truncated to 16 bytes for URL length optimization
  - Uses timing-safe comparison (hmac.compare_digest)

PROTECTION #2: Timestamp Validation
  - Token must be used within 2-hour window
  - Prevents replay attacks with old tokens
  - Uses minute-resolution for compact encoding

PROTECTION #3: Base64 URL-Safe Encoding
  - Safe for URL transmission
  - No special characters that need escaping

PROTECTION #4: Binary Packing
  - More compact than JSON
  - Harder to manually manipulate
  - Type-safe parsing (struct module)

ATTACK SCENARIOS PREVENTED:
  âŒ User cannot change subscription price
  âŒ User cannot change subscription duration
  âŒ User cannot change wallet address (redirect payment)
  âŒ User cannot change channel access
  âŒ Old tokens cannot be reused after expiry
  âŒ Tokens from other services won't validate

================================================================================
ğŸ”„ DATA SOURCES & FLOW
================================================================================

WHERE EACH FIELD COMES FROM:

user_id:
  â”œâ”€ Source: Telegram Update object
  â”œâ”€ Extracted: update.effective_user.id
  â””â”€ Used: Identify who paid

closed_channel_id:
  â”œâ”€ Source: PostgreSQL database (main_clients_database table)
  â”œâ”€ Query: db_manager.fetch_closed_channel_id(open_channel_id)
  â””â”€ Used: Which channel to grant access to

wallet_address:
  â”œâ”€ Source: PostgreSQL database (main_clients_database table)
  â”œâ”€ Query: db_manager.fetch_client_wallet_info(open_channel_id)
  â””â”€ Used: Where to send cryptocurrency payout

payout_currency:
  â”œâ”€ Source: PostgreSQL database (main_clients_database table)
  â”œâ”€ Query: db_manager.fetch_client_wallet_info(open_channel_id)
  â””â”€ Used: What currency to convert payment into

subscription_time:
  â”œâ”€ Source: Subscription tier configuration
  â”œâ”€ From: Deep link token or database lookup
  â””â”€ Used: How long the subscription lasts

subscription_price:
  â”œâ”€ Source: Subscription tier configuration
  â”œâ”€ From: Deep link token or database lookup
  â””â”€ Used: How much user paid (for payment splitting)

timestamp_minutes:
  â”œâ”€ Source: Current time when URL is generated
  â”œâ”€ Calculation: int(time.time() // 60) % 65536
  â””â”€ Used: Prevent token replay attacks

================================================================================
âš™ï¸ ENVIRONMENT VARIABLES USED
================================================================================

In TelePay7-14 (Token Generation):
  âœ“ SUCCESS_URL_SIGNING_KEY - HMAC signing key (Secret Manager path)
  âœ“ WEBHOOK_BASE_URL - Base URL for webhook (direct value)
  âœ“ PAYMENT_PROVIDER_SECRET_NAME - NowPayments API key (Secret Manager path)

In GCWebhook7-14 (Token Verification):
  âœ“ SUCCESS_URL_SIGNING_KEY - HMAC signing key (Secret Manager path)
  âœ“ TELEGRAM_BOT_SECRET_NAME - Bot token (Secret Manager path)
  âœ“ DATABASE_NAME_SECRET - Database name (Secret Manager path)
  âœ“ DATABASE_USER_SECRET - Database user (Secret Manager path)
  âœ“ DATABASE_PASSWORD_SECRET - Database password (Secret Manager path)
  âœ“ CLOUD_SQL_CONNECTION_NAME - Cloud SQL instance (direct value)
  âœ“ TPS_WEBHOOK_URL - Payment split webhook URL (direct value)

================================================================================
ğŸ› DEBUGGING & MONITORING
================================================================================

KEY LOG MESSAGES TO WATCH:

Token Generation (TelePay7-14):
  ğŸ“¦ [DEBUG] Packing for token: user_id=X, closed_channel_id=Y, timestamp_minutes=Z
  ğŸ’° [DEBUG] Wallet: 'ADDRESS' (N bytes), Currency: 'CUR' (M bytes)
  âœ… [DEBUG] Complete success URL generated: https://...
  ğŸ“ [DEBUG] Token length: N characters
  ğŸ“Š [DEBUG] Payload size: N bytes

Token Verification (GCWebhook7-14):
  ğŸ” [DEBUG] raw: <hex>
  ğŸ“¦ [DEBUG] data: <hex>
  ğŸ” [DEBUG] sig: <hex>
  ğŸ’° [DEBUG] wallet_address: 'X', payout_currency: 'Y'
  ğŸ”“ [DEBUG] Decoded user_id: X, closed_channel_id: Y
  âœ… [INFO] Successfully decoded token - User: X, Channel: Y

Common Errors:
  âŒ Missing token - User accessed webhook without token parameter
  âŒ Signature mismatch - Token was tampered with or wrong signing key
  âŒ Token expired or not yet valid - Token outside 2-hour window
  âŒ Invalid token: too small - Corrupted or incomplete token
  âŒ Could not determine user ID - Telegram update missing user info

================================================================================
ğŸ“ SUMMARY
================================================================================

WEBHOOK TRIGGER MECHANISM:
  âœ— NOT a traditional webhook (no POST with JSON)
  âœ“ Browser redirect from NowPayments after successful payment
  âœ“ GET request with signed token in query parameter
  âœ“ Token contains all necessary data pre-signed

PAYLOAD FORMAT:
  âœ— NOT JSON
  âœ“ Base64-encoded binary structure
  âœ“ Contains: user_id, channel_id, wallet, currency, price, time
  âœ“ Protected by HMAC-SHA256 signature

PAYLOAD GENERATION:
  âœ“ Generated in TelePay7-14 BEFORE payment starts
  âœ“ Embedded in NowPayments invoice success_url field
  âœ“ NowPayments redirects to this URL after payment

KEY FILES:
  - Token Generator: TelePay7-14/secure_webhook.py (build_signed_success_url)
  - Token Consumer: GCWebhook7-14/tph7-14.py (decode_and_verify_token)
  - Payment Initiator: TelePay7-14/start_np_gateway.py (start_np_gateway_new)

SECURITY:
  âœ“ Cryptographically signed (HMAC-SHA256)
  âœ“ Timestamp validation (2-hour window)
  âœ“ Tamper-proof (signature verification)
  âœ“ Prevents replay attacks

DATA FLOW:
  User â†’ Bot â†’ Generate Token â†’ NowPayments â†’ User Pays â†’ Redirect â†’ Webhook â†’ Verify â†’ Grant Access

================================================================================
Generated: 2025-10-15
Last Updated: 2025-10-15
Codebase: TelegramFunnel/OCTOBER/10-9
================================================================================
