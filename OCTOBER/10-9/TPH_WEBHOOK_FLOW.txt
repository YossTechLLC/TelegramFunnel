================================================================================
TPH7-14 WEBHOOK FLOW ANALYSIS
OCTOBER/10-9 - Complete Payment Success Webhook Documentation
================================================================================

This document provides a comprehensive analysis of how the tph7-14.py webhook
is triggered, what payload is sent, and where that payload is generated.

================================================================================
🎯 EXECUTIVE SUMMARY
================================================================================

WEBHOOK PURPOSE:
The tph7-14.py webhook (GCWebhook7-14) is NOT a traditional webhook that
receives POST requests with JSON payloads. Instead, it is a GET endpoint that
receives payment success redirects from NowPayments with a cryptographically
signed token in the URL query string.

TRIGGER METHOD:
  - User completes payment on NowPayments
  - NowPayments redirects user's browser to the success URL
  - Success URL contains an encoded token with all payment/user data
  - Token is generated by TelePay7-14 BEFORE payment begins

PAYLOAD TYPE: URL Query Parameter (NOT JSON)
  - Parameter name: "token"
  - Format: Base64-encoded binary data with HMAC signature
  - Transport: HTTP GET request (browser redirect)

KEY INSIGHT:
The "payload" is NOT sent TO the webhook—it's embedded IN the webhook URL
when the payment invoice is first created. NowPayments simply redirects to
this pre-signed URL after successful payment.

================================================================================
📊 COMPLETE FLOW DIAGRAM
================================================================================

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 1: User Initiates Payment                                         │
└─────────────────────────────────────────────────────────────────────────┘
  User clicks subscription button in Telegram bot
  ↓
  TelePay7-14/menu_handlers.py handles callback
  ↓
  Calls payment_gateway_wrapper()
  ↓
  Routes to PaymentGatewayManager.start_np_gateway_new()

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 2: Gather Payment Data (TelePay7-14)                              │
└─────────────────────────────────────────────────────────────────────────┘
  File: TelePay7-14/start_np_gateway.py
  Function: start_np_gateway_new() [Lines 175-243]

  Data Collected:
    ✓ user_id: From Telegram update
    ✓ global_open_channel_id: From subscription token
    ✓ global_sub_value: Subscription price (e.g., 15.00)
    ✓ global_sub_time: Subscription duration in days (e.g., 30)

  Database Lookups:
    ✓ closed_channel_id: Fetched from database via db_manager
    ✓ client_wallet_address: Fetched from database
    ✓ client_payout_currency: Fetched from database
    ✓ closed_channel_title: Fetched from database
    ✓ closed_channel_description: Fetched from database

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 3: Generate Signed Success URL (TelePay7-14)                      │
└─────────────────────────────────────────────────────────────────────────┘
  File: TelePay7-14/start_np_gateway.py [Lines 224-231]

  Code:
  ```python
  secure_success_url = webhook_manager.build_signed_success_url(
      user_id=user_id,
      closed_channel_id=closed_channel_id,
      client_wallet_address=wallet_address or "",
      client_payout_currency=payout_currency or "",
      subscription_time=global_sub_time,
      subscription_price=str(global_sub_value)
  )
  ```

  ↓ Calls →

  File: TelePay7-14/secure_webhook.py
  Function: build_signed_success_url() [Lines 58-154]

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 4: Token Generation Process (TelePay7-14)                         │
└─────────────────────────────────────────────────────────────────────────┘
  File: TelePay7-14/secure_webhook.py
  Function: build_signed_success_url()

  INPUT PARAMETERS:
    - user_id: int (Telegram user ID)
    - closed_channel_id: int (Premium channel ID)
    - client_wallet_address: str (Max 110 chars)
    - client_payout_currency: str (Max 4 chars)
    - subscription_time: int (1-999 days)
    - subscription_price: str (e.g., "15.00", max 6 chars)

  ENCODING PROCESS:

  Step 4.1: Convert IDs to 48-bit integers
    user_id_bytes = user_id.to_bytes(6, 'big')           # 6 bytes
    channel_id_bytes = closed_channel_id.to_bytes(6, 'big')  # 6 bytes

  Step 4.2: Pack timestamp
    timestamp_minutes = int(time.time() // 60) % 65536   # 2 bytes
    # Uses 16-bit value with ~45 day wrap-around cycle

  Step 4.3: Encode strings to UTF-8 bytes
    wallet_bytes = wallet_address.encode('utf-8')        # Variable length
    currency_bytes = payout_currency.encode('utf-8')     # Variable length
    price_bytes = subscription_price.encode('utf-8')     # Variable length

  Step 4.4: Build packed binary structure
    packed = (
        user_id_bytes                        # 6 bytes: User ID
        + channel_id_bytes                   # 6 bytes: Channel ID
        + struct.pack(">H", timestamp_minutes)  # 2 bytes: Timestamp
        + struct.pack(">H", subscription_time)  # 2 bytes: Sub duration
        + struct.pack(">B", len(price_bytes))   # 1 byte: Price length
        + price_bytes                           # N bytes: Price string
        + struct.pack(">B", len(wallet_bytes))  # 1 byte: Wallet length
        + wallet_bytes                          # M bytes: Wallet address
        + struct.pack(">B", len(currency_bytes)) # 1 byte: Currency length
        + currency_bytes                        # P bytes: Currency code
    )

  Step 4.5: Create HMAC signature
    full_signature = hmac.new(
        signing_key.encode(),
        packed,
        hashlib.sha256
    ).digest()                               # 32 bytes full signature
    signature = full_signature[:16]          # 16 bytes truncated

  Step 4.6: Combine data and signature
    payload = packed + signature

  Step 4.7: Base64 encode
    token = base64.urlsafe_b64encode(payload).decode().rstrip("=")

  Step 4.8: Build final URL
    success_url = f"{base_url}?token={token}"
    # Example: https://webhook.example.com?token=ABC123XYZ...

  BINARY STRUCTURE DIAGRAM:
  ┌─────────┬──────────┬───────────┬──────────┬────────────────────────────┐
  │ User ID │ Chan ID  │ Timestamp │ Sub Time │ Variable-Length Data       │
  │ 6 bytes │ 6 bytes  │ 2 bytes   │ 2 bytes  │ Price + Wallet + Currency  │
  └─────────┴──────────┴───────────┴──────────┴────────────────────────────┘
  └──────────────────────────────────────────────────────────────────────────┘
                              Signed with HMAC-SHA256
                              (16-byte truncated signature appended)

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 5: Create NowPayments Invoice (TelePay7-14)                       │
└─────────────────────────────────────────────────────────────────────────┘
  File: TelePay7-14/start_np_gateway.py
  Function: start_payment_flow() [Lines 106-173]
  Then calls: create_payment_invoice() [Lines 33-88]

  NowPayments API Request:
    POST https://api.nowpayments.io/v1/invoice
    Headers:
      x-api-key: <NOWPAYMENTS_API_KEY>
      Content-Type: application/json

    Body:
    {
        "price_amount": 15.00,              // Subscription price
        "price_currency": "USD",
        "order_id": "PGP-123456-1001234567890",  // User ID + Channel ID
        "order_description": "Payment-Test-1",
        "success_url": "https://webhook.example.com?token=ABC123...",  // ← OUR SIGNED URL
        "is_fixed_rate": false,
        "is_fee_paid_by_user": false
    }

    Response (if successful):
    {
        "invoice_url": "https://nowpayments.io/payment/...",  // User goes here
        "id": "123456",
        "order_id": "PGP-123456-1001234567890",
        // ... other fields ...
    }

  ⭐ KEY POINT: The "success_url" field contains our signed token!

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 6: User Completes Payment (External: NowPayments)                 │
└─────────────────────────────────────────────────────────────────────────┘
  User is directed to NowPayments invoice page
  ↓
  User selects cryptocurrency and completes payment
  ↓
  NowPayments confirms payment received
  ↓
  NowPayments redirects user's browser:
    GET https://webhook.example.com?token=ABC123...

  ⭐ KEY POINT: This is a BROWSER REDIRECT, not a webhook POST!

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 7: Webhook Receives Request (GCWebhook7-14)                       │
└─────────────────────────────────────────────────────────────────────────┘
  File: GCWebhook7-14/tph7-14.py
  Flask Route: @app.route("/", methods=["GET"])
  Function: send_invite() [Lines 500-615]

  Request Details:
    Method: GET (not POST!)
    URL: https://webhook.example.com?token=ABC123XYZ...
    Parameters:
      - token: Base64-encoded signed payload
    Headers: Standard browser headers (not webhook-specific)

  Code Flow:

  Line 503: Extract token from URL
    token = request.args.get("token")

  Lines 508-509: Fetch credentials
    bot_token = fetch_telegram_bot_token()
    signing_key = fetch_success_url_signing_key()

  Line 523: Decode and verify token
    user_id, closed_channel_id, wallet_address, payout_currency,
    subscription_time_days, subscription_price = decode_and_verify_token(token, signing_key)

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 8: Token Decoding Process (GCWebhook7-14)                         │
└─────────────────────────────────────────────────────────────────────────┘
  File: GCWebhook7-14/tph7-14.py
  Function: decode_and_verify_token() [Lines 82-201]

  DECODING PROCESS:

  Step 8.1: Base64 decode
    padding = '=' * (-len(token) % 4)
    raw = base64.urlsafe_b64decode(token + padding)

  Step 8.2: Parse fixed fields
    user_id = int.from_bytes(raw[0:6], 'big')              # Bytes 0-5
    closed_channel_id = int.from_bytes(raw[6:12], 'big')   # Bytes 6-11
    timestamp_minutes = struct.unpack(">H", raw[12:14])[0] # Bytes 12-13
    subscription_time_days = struct.unpack(">H", raw[14:16])[0]  # Bytes 14-15

  Step 8.3: Parse variable-length subscription price
    offset = 16
    price_len = struct.unpack(">B", raw[offset:offset+1])[0]
    offset += 1
    subscription_price = raw[offset:offset+price_len].decode('utf-8')
    offset += price_len

  Step 8.4: Parse variable-length wallet address
    wallet_len = struct.unpack(">B", raw[offset:offset+1])[0]
    offset += 1
    wallet_address = raw[offset:offset+wallet_len].decode('utf-8')
    offset += wallet_len

  Step 8.5: Parse variable-length currency
    currency_len = struct.unpack(">B", raw[offset:offset+1])[0]
    offset += 1
    payout_currency = raw[offset:offset+currency_len].decode('utf-8')
    offset += currency_len

  Step 8.6: Extract signature
    data = raw[:offset]     # All data fields
    sig = raw[offset:]      # Last 16 bytes

  Step 8.7: Verify HMAC signature
    expected_full_sig = hmac.new(signing_key.encode(), data, hashlib.sha256).digest()
    expected_sig = expected_full_sig[:16]
    if not hmac.compare_digest(sig, expected_sig):
        raise ValueError("Signature mismatch")

  Step 8.8: Handle negative Telegram IDs (48-bit wraparound)
    if user_id > 2**47 - 1:
        user_id -= 2**48
    if closed_channel_id > 2**47 - 1:
        closed_channel_id -= 2**48

  Step 8.9: Reconstruct timestamp and validate
    # Convert minutes back to Unix timestamp
    # Validate token is not expired (2-hour window)
    now = int(time.time())
    if not (now - 7200 <= timestamp <= now + 300):
        raise ValueError("Token expired or not yet valid")

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 9: Process Payment Success (GCWebhook7-14)                        │
└─────────────────────────────────────────────────────────────────────────┘
  File: GCWebhook7-14/tph7-14.py
  Function: send_invite() [Lines 534-615]

  EXTRACTED DATA FROM TOKEN:
    ✓ user_id: 123456
    ✓ closed_channel_id: -1001234567890
    ✓ wallet_address: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb"
    ✓ payout_currency: "ETH"
    ✓ subscription_time_days: 30 (actually minutes for testing)
    ✓ subscription_price: "15.00"

  Step 9.1: Calculate expiration [Line 534]
    expire_time, expire_date = calculate_expiration_time(subscription_time_days)
    # Currently uses MINUTES for testing (will be days in production)

  Step 9.2: Record subscription in database [Lines 543-551]
    record_private_channel_user(
        user_id=user_id,
        private_channel_id=closed_channel_id,
        sub_time=subscription_time_days,
        sub_price=subscription_price,
        expire_time=expire_time,
        expire_date=expire_date,
        is_active=True
    )

    Database Table: private_channel_users_database
    Columns Updated:
      - user_id
      - private_channel_id
      - sub_time (minutes for testing)
      - sub_price
      - timestamp (current time)
      - datestamp (current date)
      - expire_time (HH:MM:SS)
      - expire_date (YYYY-MM-DD)
      - is_active (true)

  Step 9.3: Send Telegram invite link [Lines 565-582]
    bot.create_chat_invite_link(
        chat_id=closed_channel_id,
        expire_date=int(time.time()) + 3600,  # 1 hour expiry
        member_limit=1                         # Single use
    )

    bot.send_message(
        chat_id=user_id,
        text="✅ You've been granted access!\nHere is your one-time invite link:\n{link}"
    )

  Step 9.4: Trigger payment splitting webhook [Lines 587-592]
    trigger_payment_split_webhook(
        user_id=user_id,
        wallet_address=wallet_address,
        payout_currency=payout_currency,
        subscription_price=subscription_price
    )
    # Sends POST to GCSplit7-14/tps10-9.py for cryptocurrency conversion

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 10: Return Response to Browser (GCWebhook7-14)                    │
└─────────────────────────────────────────────────────────────────────────┘
  File: GCWebhook7-14/tph7-14.py [Line 615]

  HTTP Response:
    Status: 200 OK
    Body: {"status": "ok"}
    Content-Type: application/json

  User's browser receives this response
  (User has already received Telegram message with invite link)

================================================================================
📦 PAYLOAD STRUCTURE DETAILED BREAKDOWN
================================================================================

IMPORTANT: The "payload" is NOT a traditional webhook JSON body. Instead, it's
a binary-encoded token embedded in a URL query parameter.

FORMAT: Base64-encoded binary data

BEFORE ENCODING (Binary Structure):
┌────────────────────────────────────────────────────────────────────────┐
│ Offset │ Length │ Field                    │ Type      │ Example      │
├────────┼────────┼──────────────────────────┼───────────┼──────────────┤
│ 0      │ 6      │ user_id                  │ 48-bit BE │ 123456       │
│ 6      │ 6      │ closed_channel_id        │ 48-bit BE │ -1001234567  │
│ 12     │ 2      │ timestamp_minutes        │ 16-bit BE │ 28945        │
│ 14     │ 2      │ subscription_time        │ 16-bit BE │ 30           │
│ 16     │ 1      │ price_length             │ 8-bit     │ 5            │
│ 17     │ N      │ subscription_price       │ UTF-8     │ "15.00"      │
│ 17+N   │ 1      │ wallet_length            │ 8-bit     │ 42           │
│ 18+N   │ M      │ wallet_address           │ UTF-8     │ "0x742d..."  │
│ 18+N+M │ 1      │ currency_length          │ 8-bit     │ 3            │
│ 19+N+M │ P      │ payout_currency          │ UTF-8     │ "ETH"        │
│ 19+N+M+P│ 16    │ HMAC signature (trunc)   │ Binary    │ <16 bytes>   │
└────────┴────────┴──────────────────────────┴───────────┴──────────────┘

Total Size: 35+ bytes minimum (depending on string lengths)
  - Fixed: 19 bytes (IDs, timestamp, sub_time, length fields)
  - Variable: Price string (1-6 bytes)
  - Variable: Wallet address (0-110 bytes)
  - Variable: Currency code (0-4 bytes)
  - Signature: 16 bytes (truncated HMAC-SHA256)

AFTER BASE64 ENCODING:
  Example: "AAAAAAEePlIAbOwAu9YAAACUBTQ1LjAwKjB4NzQyZDM1Q2M2NjM0QzA1MzI5MjVhM2I4NDRCYzllNzU5NWYwYkViA0VUSJq8nKxz4pYmRd3vPQ2Bw8s="

  Characteristics:
    - URL-safe Base64 (uses - and _ instead of + and /)
    - Padding = characters stripped
    - Length: ~50-150 characters (depends on wallet address length)

EXAMPLE DECODED VALUES:
  user_id: 123456
  closed_channel_id: -1001234567890
  timestamp_minutes: 28945 (reconstructed to full Unix timestamp)
  subscription_time: 30 (days, but used as minutes in testing)
  subscription_price: "15.00"
  wallet_address: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb"
  payout_currency: "ETH"
  signature: <16 bytes of HMAC-SHA256>

================================================================================
🔐 SECURITY MECHANISMS
================================================================================

PROTECTION #1: HMAC-SHA256 Signature
  - Prevents tampering with any field (user_id, price, wallet, etc.)
  - Uses SECRET_URL_SIGNING_KEY shared between services
  - Truncated to 16 bytes for URL length optimization
  - Uses timing-safe comparison (hmac.compare_digest)

PROTECTION #2: Timestamp Validation
  - Token must be used within 2-hour window
  - Prevents replay attacks with old tokens
  - Uses minute-resolution for compact encoding

PROTECTION #3: Base64 URL-Safe Encoding
  - Safe for URL transmission
  - No special characters that need escaping

PROTECTION #4: Binary Packing
  - More compact than JSON
  - Harder to manually manipulate
  - Type-safe parsing (struct module)

ATTACK SCENARIOS PREVENTED:
  ❌ User cannot change subscription price
  ❌ User cannot change subscription duration
  ❌ User cannot change wallet address (redirect payment)
  ❌ User cannot change channel access
  ❌ Old tokens cannot be reused after expiry
  ❌ Tokens from other services won't validate

================================================================================
🔄 DATA SOURCES & FLOW
================================================================================

WHERE EACH FIELD COMES FROM:

user_id:
  ├─ Source: Telegram Update object
  ├─ Extracted: update.effective_user.id
  └─ Used: Identify who paid

closed_channel_id:
  ├─ Source: PostgreSQL database (main_clients_database table)
  ├─ Query: db_manager.fetch_closed_channel_id(open_channel_id)
  └─ Used: Which channel to grant access to

wallet_address:
  ├─ Source: PostgreSQL database (main_clients_database table)
  ├─ Query: db_manager.fetch_client_wallet_info(open_channel_id)
  └─ Used: Where to send cryptocurrency payout

payout_currency:
  ├─ Source: PostgreSQL database (main_clients_database table)
  ├─ Query: db_manager.fetch_client_wallet_info(open_channel_id)
  └─ Used: What currency to convert payment into

subscription_time:
  ├─ Source: Subscription tier configuration
  ├─ From: Deep link token or database lookup
  └─ Used: How long the subscription lasts

subscription_price:
  ├─ Source: Subscription tier configuration
  ├─ From: Deep link token or database lookup
  └─ Used: How much user paid (for payment splitting)

timestamp_minutes:
  ├─ Source: Current time when URL is generated
  ├─ Calculation: int(time.time() // 60) % 65536
  └─ Used: Prevent token replay attacks

================================================================================
⚙️ ENVIRONMENT VARIABLES USED
================================================================================

In TelePay7-14 (Token Generation):
  ✓ SUCCESS_URL_SIGNING_KEY - HMAC signing key (Secret Manager path)
  ✓ WEBHOOK_BASE_URL - Base URL for webhook (direct value)
  ✓ PAYMENT_PROVIDER_SECRET_NAME - NowPayments API key (Secret Manager path)

In GCWebhook7-14 (Token Verification):
  ✓ SUCCESS_URL_SIGNING_KEY - HMAC signing key (Secret Manager path)
  ✓ TELEGRAM_BOT_SECRET_NAME - Bot token (Secret Manager path)
  ✓ DATABASE_NAME_SECRET - Database name (Secret Manager path)
  ✓ DATABASE_USER_SECRET - Database user (Secret Manager path)
  ✓ DATABASE_PASSWORD_SECRET - Database password (Secret Manager path)
  ✓ CLOUD_SQL_CONNECTION_NAME - Cloud SQL instance (direct value)
  ✓ TPS_WEBHOOK_URL - Payment split webhook URL (direct value)

================================================================================
🐛 DEBUGGING & MONITORING
================================================================================

KEY LOG MESSAGES TO WATCH:

Token Generation (TelePay7-14):
  📦 [DEBUG] Packing for token: user_id=X, closed_channel_id=Y, timestamp_minutes=Z
  💰 [DEBUG] Wallet: 'ADDRESS' (N bytes), Currency: 'CUR' (M bytes)
  ✅ [DEBUG] Complete success URL generated: https://...
  📏 [DEBUG] Token length: N characters
  📊 [DEBUG] Payload size: N bytes

Token Verification (GCWebhook7-14):
  🔍 [DEBUG] raw: <hex>
  📦 [DEBUG] data: <hex>
  🔐 [DEBUG] sig: <hex>
  💰 [DEBUG] wallet_address: 'X', payout_currency: 'Y'
  🔓 [DEBUG] Decoded user_id: X, closed_channel_id: Y
  ✅ [INFO] Successfully decoded token - User: X, Channel: Y

Common Errors:
  ❌ Missing token - User accessed webhook without token parameter
  ❌ Signature mismatch - Token was tampered with or wrong signing key
  ❌ Token expired or not yet valid - Token outside 2-hour window
  ❌ Invalid token: too small - Corrupted or incomplete token
  ❌ Could not determine user ID - Telegram update missing user info

================================================================================
📝 SUMMARY
================================================================================

WEBHOOK TRIGGER MECHANISM:
  ✗ NOT a traditional webhook (no POST with JSON)
  ✓ Browser redirect from NowPayments after successful payment
  ✓ GET request with signed token in query parameter
  ✓ Token contains all necessary data pre-signed

PAYLOAD FORMAT:
  ✗ NOT JSON
  ✓ Base64-encoded binary structure
  ✓ Contains: user_id, channel_id, wallet, currency, price, time
  ✓ Protected by HMAC-SHA256 signature

PAYLOAD GENERATION:
  ✓ Generated in TelePay7-14 BEFORE payment starts
  ✓ Embedded in NowPayments invoice success_url field
  ✓ NowPayments redirects to this URL after payment

KEY FILES:
  - Token Generator: TelePay7-14/secure_webhook.py (build_signed_success_url)
  - Token Consumer: GCWebhook7-14/tph7-14.py (decode_and_verify_token)
  - Payment Initiator: TelePay7-14/start_np_gateway.py (start_np_gateway_new)

SECURITY:
  ✓ Cryptographically signed (HMAC-SHA256)
  ✓ Timestamp validation (2-hour window)
  ✓ Tamper-proof (signature verification)
  ✓ Prevents replay attacks

DATA FLOW:
  User → Bot → Generate Token → NowPayments → User Pays → Redirect → Webhook → Verify → Grant Access

================================================================================
Generated: 2025-10-15
Last Updated: 2025-10-15
Codebase: TelegramFunnel/OCTOBER/10-9
================================================================================
